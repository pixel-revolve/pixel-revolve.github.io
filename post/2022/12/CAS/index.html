<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.38">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/img/logo-broccoli.png"><title>CAS和Unsafe类 | pixel-revolve</title><meta name="description" content="爱编程，爱生活">
    <link rel="modulepreload" href="/assets/app.9fd9aa02.js"><link rel="modulepreload" href="/assets/index.html.f5a7f445.js"><link rel="modulepreload" href="/assets/index.html.1b0b135b.js">
    <link rel="stylesheet" href="/assets/style.2781e754.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container no-sidebar"><!--[--><header class="navbar invert"><span><a href="/" class=""><span class="site-name">$ cd /home/</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="Home"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/></svg></span><span>Home</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/tags/" class="" aria-label="Tags"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M17.707 9.293a1 1 0 010 1.414l-7 7a1 1 0 01-1.414 0l-7-7A.997.997 0 012 10V5a3 3 0 013-3h5c.256 0 .512.098.707.293l7 7zM5 6a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/></svg></span><span>Tags</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/links/" class="" aria-label="Links"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z" clip-rule="evenodd"/></svg></span><span>Links</span><!--[--><!--]--></a></div><!--]--><div class="navbar-item"><a style="cursor:pointer;"><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 2c4.968 0 9 4.032 9 9s-4.032 9-9 9-9-4.032-9-9 4.032-9 9-9zm0 16c3.867 0 7-3.133 7-7 0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7zm8.485.071l2.829 2.828-1.415 1.415-2.828-2.829 1.414-1.414z"/></svg></span><span>Search</span></a></div></nav><!--[--><!--]--><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="Home"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/></svg></span><span>Home</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/tags/" class="" aria-label="Tags"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M17.707 9.293a1 1 0 010 1.414l-7 7a1 1 0 01-1.414 0l-7-7A.997.997 0 012 10V5a3 3 0 013-3h5c.256 0 .512.098.707.293l7 7zM5 6a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/></svg></span><span>Tags</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/links/" class="" aria-label="Links"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z" clip-rule="evenodd"/></svg></span><span>Links</span><!--[--><!--]--></a></div><!--]--><div class="navbar-item"><a style="cursor:pointer;"><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 2c4.968 0 9 4.032 9 9s-4.032 9-9 9-9-4.032-9-9 4.032-9 9-9zm0 16c3.867 0 7-3.133 7-7 0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7zm8.485.071l2.829 2.828-1.415 1.415-2.828-2.829 1.414-1.414z"/></svg></span><span>Search</span></a></div></nav><!--[--><!--]--><!----><!--[--><!--]--></aside><!--]--><div class="page-content"><!--[--><div class="show-catalog post-wrapper"><div class="article-header use-image post-header" style="background-image:url(/img/blog_cover/2022/12/CAS和Unsafe类.jpg);"><div class="article-header-mask" style="background:rgba(40, 57, 101, .4);"></div><div class="article-header-content"><div class="article-tags"><!--[--><span class="article-tag">并发编程</span><!--]--></div><h1 class="article-title">CAS和Unsafe类</h1><p class="article-subtitle">无锁并发安全的保障</p><div class="article-icons"><div class="article-icon"><svg class="ov-icon" style="font-size:1.08em;" aria-hidden="true" width="17.28" height="17.28" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M313.6 304c-28.7 0-42.5 16-89.6 16-47.1 0-60.8-16-89.6-16C60.2 304 0 364.2 0 438.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-25.6c0-74.2-60.2-134.4-134.4-134.4zM400 464H48v-25.6c0-47.6 38.8-86.4 86.4-86.4 14.6 0 38.3 16 89.6 16 51.7 0 74.9-16 89.6-16 47.6 0 86.4 38.8 86.4 86.4V464zM224 288c79.5 0 144-64.5 144-144S303.5 0 224 0 80 64.5 80 144s64.5 144 144 144zm0-240c52.9 0 96 43.1 96 96s-43.1 96-96 96-96-43.1-96-96 43.1-96 96-96z"/></svg><span>pixel-revolve</span></div><div class="article-icon"><svg class="ov-icon" style="font-size:1.08em;" aria-hidden="true" width="17.28" height="17.28" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M400 64h-48V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H160V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zm-6 400H54c-3.3 0-6-2.7-6-6V160h352v298c0 3.3-2.7 6-6 6z"/></svg><span>2022-12-05</span></div><div class="article-icon"><svg class="ov-icon" style="font-size:1.08em;" aria-hidden="true" width="17.28" height="17.28" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M17.618 5.968l1.453-1.453 1.414 1.414-1.453 1.453a9 9 0 11-1.414-1.414zM12 20a7 7 0 100-14 7 7 0 000 14zM11 8h2v6h-2V8zM8 1h8v2H8V1z"/></svg><span>23 min</span></div></div></div><!----></div><main class="page post-content"><!--[--><!--]--><div class="theme-gungnir-content"><!--[--><h1 id="简单介绍" tabindex="-1"><a class="header-anchor" href="#简单介绍" aria-hidden="true">#</a> 简单介绍</h1><h2 id="乐观锁和悲观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁和悲观锁" aria-hidden="true">#</a> 乐观锁和悲观锁</h2><blockquote><p>什么是乐观锁，悲观锁？</p></blockquote><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。</p><p>对于同一个数据的并发操作：</p><ul><li>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</li><li>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，<strong>只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。</strong> 如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</li></ul><blockquote><p>乐观锁，悲观锁的实现</p></blockquote><ul><li><p>乐观锁的实现</p><ul><li><p><code>CAS</code>算法</p><p>Java原子类中的递增操作就是通过<code>CAS</code>自旋实现的。</p></li></ul></li><li><p>悲观锁的实现</p><ul><li><code>synchronized</code>关键字的实现类</li><li><code>Lock</code>的实现类</li></ul></li></ul><blockquote><p>乐观锁和悲观锁的适用场景</p></blockquote><ul><li><strong>悲观锁适合写操作多的场景</strong>，先加锁可以保证写操作时数据正确。</li><li><strong>乐观锁适合读操作多的场景</strong>，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><h1 id="cas概述" tabindex="-1"><a class="header-anchor" href="#cas概述" aria-hidden="true">#</a> CAS概述</h1><h2 id="什么是cas" tabindex="-1"><a class="header-anchor" href="#什么是cas" aria-hidden="true">#</a> 什么是CAS？</h2><blockquote><p>什么是<code>CAS</code>？</p></blockquote><p><code>CAS</code>是<code>Compare And Swap</code>的缩写，直译就是<strong>比较并交换</strong>。</p><p><code>CAS</code>是现代<code>CPU</code>广泛支持的一种对内存中的共享数据进行操作的一种特殊指令，这个指令会对内存中的共享数据做<strong>原子的读写操作</strong>。其作用是<strong>让<code>CPU</code>比较内存中某个值是否和预期的值相同，如果相同则将这个值更新为新值，不相同则不做更新。</strong></p><ul><li><blockquote><p><code>CAS</code>如何实现？</p></blockquote><p><code>CAS</code>的实现方式是基于硬件平台的汇编指令，就是说<code>CAS</code>是<strong>靠硬件实现的</strong>，<code>JVM</code>只是<strong>封装了汇编调用</strong>，那些<code>AtomicInteger</code>类便是使用了这些封装后的接口。</p></li></ul><ul><li><blockquote><p><code>CAS</code>是一种基于乐观锁的操作？</p></blockquote><p>使用锁时，线程获取锁是一种<strong>悲观锁策略</strong>，即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。</p><p>而<code>CAS</code>操作（又称为无锁操作）是一种<strong>乐观锁策略</strong>，它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。因此，线程就不会出现阻塞停顿的状态。</p><p><code>CAS</code>可以保证在多线程并发中保障共享资源的原子性操作，相较于<code>synchronized</code>来说是一种轻量级的实现方案。</p></li></ul><ul><li><blockquote><p>如果出现冲突了怎么办？</p></blockquote><p>无锁操作是使用**<code>CAS</code>(compare and swap)** 又叫做比较交换来鉴别线程是否出现冲突，出现冲突就<strong>重试当前操作直到没有冲突为止。</strong></p></li></ul><blockquote><p>Java如何调用<code>CAS</code>？</p></blockquote><p>Java中并没有直接实现<code>CAS</code>，<code>CAS</code>相关的实现是借助C/C++调用CPU指令来实现的，效率很高，但Java代码需通过<code>JNI</code>才能调用。</p><p>比如，<code>Unsafe</code>类提供的<code>CAS</code>方法（如<code>compareAndSwapXXX</code>）底层实现即为CPU指令<code>cmpxchg</code>。</p><h2 id="cas操作流程" tabindex="-1"><a class="header-anchor" href="#cas操作流程" aria-hidden="true">#</a> CAS操作流程</h2><blockquote><p>CAS的操作过程</p></blockquote><p><code>CAS</code>比较交换的过程可以通俗的理解为<code>CAS</code>(V,O,N)，包含的三个值分别为：</p><ul><li><strong>V 内存地址存放的实际值</strong></li><li><strong>O 预期的值（旧值）</strong></li><li><strong>N 更新的新值</strong></li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a23288170fc947d4819f3f8ac8ba05b3~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>当<code>V</code>和<code>O</code>相同时，也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值<code>O</code>就是目前来说最新的值了，自然而然可以将新值<code>N</code>赋值给<code>V</code>。</p><p>反之，<code>V</code>和<code>O</code>不相同，表明该值已经被其他线程改过了则该旧值<code>O</code>不是最新版本的值了，所以不能将新值<code>N</code>赋给<code>V</code>，返回<code>V</code>即可。当多个线程使用<code>CAS</code>操作一个变量是，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试，当然也可以选择挂起线程。</p><h2 id="cas问题" tabindex="-1"><a class="header-anchor" href="#cas问题" aria-hidden="true">#</a> CAS问题</h2><blockquote><p><code>CAS</code>解决并发问题相比于<code>synchronized</code>性能更优，但是也会引发以下问题</p></blockquote><h3 id="aba问题" tabindex="-1"><a class="header-anchor" href="#aba问题" aria-hidden="true">#</a> ABA问题</h3><blockquote><p>什么是<code>ABA</code>问题？</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c10d57da093a4fa9956722a23c491f68~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>因为<code>CAS</code>需要在操作值的时候，检查值有没有发生变化，比如没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用<code>CAS</code>进行检查时则会发现它的值没有发生变化，但是实际上却变化了。</p><ul><li><blockquote><p>如何解决<code>ABA</code>问题？</p></blockquote><p><code>ABA</code>问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么<code>A-&gt;B-&gt;A</code>就会变成<code>1A-&gt;2B-&gt;3A</code>。</p><p>从Java 1.5开始，<code>JDK</code>的<code>Atomic</code>包里提供了一个<strong>原子引用类</strong><code>AtomicStampedReference</code>来解决<code>ABA</code>问题。</p><p><code>AtomicStampedReference</code>的<code>compareAndSet</code>方法的作用是首先检查<strong>当前引用是否等于预期引用</strong>，并且检查<strong>当前标志是否等于预期标志</strong>，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p></li></ul><h3 id="循环时间长开销大" tabindex="-1"><a class="header-anchor" href="#循环时间长开销大" aria-hidden="true">#</a> 循环时间长开销大</h3><blockquote><p>什么是循环时间长开销大问题？</p></blockquote><p>自旋<code>CAS</code>如果长时间不成功，会<strong>给<code>CPU</code>带来非常大的执行开销。</strong></p><p>如果<code>JVM</code>能支持处理器提供的<code>pause</code>指令，那么效率会有一定的提升。</p><ul><li><blockquote><p><code>pause</code>指令有什么用？</p></blockquote><p><code>pause</code>指令有两个作用：</p><ul><li>延迟流水线执行命令(de-pipeline)，使<code>CPU</code><strong>不会消耗过多的执行资源</strong>，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；</li><li>避免在退出循环的时候因内存顺序冲突(Memory Order Violation)而引起<code>CPU</code>流水线被清空(CPU Pipeline Flush)，从而<strong>提高<code>CPU</code>的执行效率。</strong></li></ul></li></ul><h3 id="只能保证一个共享变量的原子操作" tabindex="-1"><a class="header-anchor" href="#只能保证一个共享变量的原子操作" aria-hidden="true">#</a> 只能保证一个共享变量的原子操作</h3><blockquote><p>什么是只能保证一个共享变量的原子操作问题？</p></blockquote><p>当对<strong>一个</strong>共享变量执行操作时，我们可以<strong>使用循环<code>CAS</code>的方式来保证原子操作</strong>，但是对<strong>多个</strong>共享变量操作时，循环<code>CAS</code>就<strong>无法保证操作的原子性</strong>，这个时候就得用到锁来保证原子操作了。</p><ul><li><blockquote><p>还有一个取巧的办法</p></blockquote><p>把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量<code>i = 2</code>，<code>j = a</code>，合并一下<code>ij = 2a</code>，然后用<code>CAS</code>来操作<code>ij</code>。</p><p>从Java 1.5开始，<code>JDK</code>提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行<code>CAS</code>操作。</p></li></ul><h1 id="cas工作原理" tabindex="-1"><a class="header-anchor" href="#cas工作原理" aria-hidden="true">#</a> CAS工作原理</h1><blockquote><p><code>CAS</code>的实现原理简单来说就是由<code>Unsafe</code>类和其中的自旋锁来完成的。</p></blockquote><h2 id="什么是unsafe类" tabindex="-1"><a class="header-anchor" href="#什么是unsafe类" aria-hidden="true">#</a> 什么是Unsafe类？</h2><blockquote><p>什么是<code>Unsafe</code>类？</p></blockquote><p><code>Unsafe</code>是位于<code>sun.misc</code>包下的一个类，<strong>Java原子类是通过<code>Unsafe</code>类实现的</strong>。</p><p><code>Unsafe</code>主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。</p><p>但由于**<code>Unsafe</code>类使Java语言拥有了类似C语言指针一样操作内存空间的能力**，这无疑也增加了程序发生相关指针问题的风险。正因为如此<code>Unsafe</code>才类如其名。</p><h2 id="unsafe类源码" tabindex="-1"><a class="header-anchor" href="#unsafe类源码" aria-hidden="true">#</a> Unsafe类源码</h2><h3 id="unsafe的单例实现" tabindex="-1"><a class="header-anchor" href="#unsafe的单例实现" aria-hidden="true">#</a> Unsafe的单例实现</h3><blockquote><p><code>Unsafe</code>类的单例实现：</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> public final class Unsafe {
   // 单例对象
   private static final Unsafe theUnsafe;
 ​
   private Unsafe() {
   }
   @CallerSensitive
   public static Unsafe getUnsafe() {
     Class var0 = Reflection.getCallerClass();
     // 仅在引导类加载器`BootstrapClassLoader`加载时才合法
     if(!VM.isSystemDomainLoader(var0.getClassLoader())) {    
       throw new SecurityException(&quot;Unsafe&quot;);
     } else {
       return theUnsafe;
     }
   }
 }
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><code>Unsafe</code>类为一单例实现，提供静态方法<code>getUnsafe</code>获取<code>Unsafe</code>实例，当且仅当调用<code>getUnsafe</code>方法的类为引导类加载器所加载时才合法，否则抛出<code>SecurityException</code>异常。</p><ul><li><blockquote><p>如何获取<code>Unsafe</code>类的实例？</p></blockquote><ul><li><p>方法一：加命令行参数然后调用单例实例获取方法</p><p>从<code>getUnsafe</code>方法的使用限制条件出发，通过Java命令行命令<code>-Xbootclasspath/a</code>把调用<code>Unsafe</code>相关方法的类A所在jar包路径追加到默认的<code>bootstrap</code>路径中，使得A被引导类加载器加载。</p><p>从而通过<code>Unsafe.getUnsafe</code>方法安全的获取<code>Unsafe</code>实例。</p></li><li><p>方法二：通过反射获取单例对象<code>theUnsafe</code></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> private static Unsafe reflectGetUnsafe() {
     try {
       Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
       field.setAccessible(true);
       return (Unsafe) field.get(null);
     } catch (Exception e) {
       log.error(e.getMessage(), e);
       return null;
     }
 }
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li></ul></li></ul><h3 id="unsafe的api" tabindex="-1"><a class="header-anchor" href="#unsafe的api" aria-hidden="true">#</a> Unsafe的API</h3><blockquote><p><code>Unsafe</code>的API？</p></blockquote><p>这里我们直接借用了美团技术团队的思维导图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f2e72ce3daf47a88d219b741506de4f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>可以知道<code>Unsafe</code>类的API按照功能分类如下：</p><ul><li><p><strong>内存操作：</strong></p><ul><li><blockquote><p>主要包括</p></blockquote><ul><li>分类、拷贝、扩充、释放堆外内存</li><li>设置、获得给定地址中的值</li></ul></li><li><blockquote><p>相关方法</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> //分配内存, 相当于C++的malloc函数
 public native long allocateMemory(long bytes);
 //扩充内存
 public native long reallocateMemory(long address, long bytes);
 //释放内存
 public native void freeMemory(long address);
 //在给定的内存块中设置值
 public native void setMemory(Object o, long offset, long bytes, byte value);
 //内存拷贝
 public native void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);
 //获取给定地址值，忽略修饰限定符的访问限制。与此类似操作还有: getInt，getDouble，getLong，getChar等
 public native Object getObject(Object o, long offset);
 //为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有: putInt,putDouble，putLong，putChar等
 public native void putObject(Object o, long offset, Object x);
 //获取给定地址的byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果为确定的）
 public native byte getByte(long address);
 //为给定地址设置byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果才是确定的）
 public native void putByte(long address, byte x);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div></li></ul></li><li><p><strong>CAS</strong></p><ul><li><blockquote><p>相关方法</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> public final native boolean compareAndSwapObject(Object o, long offset,  Object expected, Object update);
 ​
 public final native boolean compareAndSwapInt(Object o, long offset, int expected,int update);
   
 public final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>我们都知道，<code>CAS</code>是一条<code>CPU</code>的原子指令（<code>cmpxchg</code>指令），不会造成所谓的数据不一致问题，<code>Unsafe</code>提供的<code>CAS</code>方法（如<code>compareAndSwapXXX</code>）底层实现即为<code>CPU</code>指令<code>cmpxchg</code>。</p><p>我们会在「Unsafe的CAS操作相关方法」和「compareAndSwapInt」两个章节补全<code>CAS</code>操作的实现相关内容。</p></li><li><blockquote><p>应用</p></blockquote><p><code>CAS</code>在<code>java.util.concurrent.atomic</code>相关类、<code>Java AQS</code>、<code>CurrentHashMap</code>等实现上有非常广泛的应用。</p></li></ul></li><li><p><strong>Class相关</strong></p><ul><li><blockquote><p>主要包括</p></blockquote><ul><li>动态创建类（普通类&amp;匿名类）</li><li>获取field的内存地址偏移量</li><li>检测、确保类初始化</li></ul></li><li><blockquote><p>相关方法</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> //获取给定静态字段的内存地址偏移量，这个值对于给定的字段是唯一且固定不变的
 public native long staticFieldOffset(Field f);
 //获取一个静态类中给定字段的对象指针
 public native Object staticFieldBase(Field f);
 //判断是否需要初始化一个类，通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。 当且仅当ensureClassInitialized方法不生效时返回false。
 public native boolean shouldBeInitialized(Class&lt;?&gt; c);
 //检测给定的类是否已经初始化。通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。
 public native void ensureClassInitialized(Class&lt;?&gt; c);
 //定义一个类，此方法会跳过JVM的所有安全检查，默认情况下，ClassLoader（类加载器）和ProtectionDomain（保护域）实例来源于调用者
 public native Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain);
 //定义一个匿名类
 public native Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li><li><blockquote><p>应用</p></blockquote><p>从JDK1.8开始，使用<code>invokedynamic</code>及<code>VM Anonymous Class</code>结合来实现Java语言层面上的Lambda表达式。</p></li></ul></li><li><p><strong>对象操作</strong></p><ul><li><blockquote><p>主要包括</p></blockquote><ul><li>获取对象成员属性在内存偏移量</li><li>非常规对象实例化</li><li>存储、获取指定偏移量地址的变量值（包含延迟生效、volatile语义）</li></ul></li><li><blockquote><p>相关方法</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> //返回对象成员属性在内存地址相对于此对象的内存地址的偏移量
 public native long objectFieldOffset(Field f);
 //获得给定对象的指定地址偏移量的值，与此类似操作还有：getInt，getDouble，getLong，getChar等
 public native Object getObject(Object o, long offset);
 //给定对象的指定地址偏移量设值，与此类似操作还有：putInt，putDouble，putLong，putChar等
 public native void putObject(Object o, long offset, Object x);
 //从对象的指定偏移量处获取变量的引用，使用volatile的加载语义
 public native Object getObjectVolatile(Object o, long offset);
 //存储变量的引用到对象的指定的偏移量处，使用volatile的存储语义
 public native void putObjectVolatile(Object o, long offset, Object x);
 //有序、延迟版本的putObjectVolatile方法，不保证值的改变被其他线程立即看到。只有在field被volatile修饰符修饰时有效
 public native void putOrderedObject(Object o, long offset, Object x);
 //绕过构造方法、初始化代码来创建对象
 public native Object allocateInstance(Class&lt;?&gt; cls) throws InstantiationException;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div></li><li><blockquote><p>应用</p></blockquote><ul><li><p><strong>常规对象实例化方式</strong>：</p><p>我们通常所用到的创建对象的方式，从本质上来讲，都是通过new机制来实现对象的创建。</p><p>但是，new机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。</p></li><li><p><strong>非常规的实例化方式</strong>：</p><p>而<code>Unsafe</code>中提供<code>allocateInstance</code>方法，仅通过Class对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、<code>JVM</code>安全检查等。</p><p>它抑制修饰符检测，也就是即使构造器是<code>private</code>修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。</p><p>由于这种特性，<code>allocateInstance</code>在<code>java.lang.invoke</code>、<code>Objenesis</code>（提供绕过类构造器的对象生成方式）、<code>Gson</code>（反序列化时用到）中都有相应的应用。</p></li></ul></li></ul></li><li><p><strong>数组相关</strong></p><ul><li><blockquote><p>主要包括</p></blockquote><ul><li>返回数组元素内存大小</li><li>返回数组首元素偏移地址</li></ul></li><li><blockquote><p>相关方法</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> //返回数组中第一个元素的偏移地址
 public native int arrayBaseOffset(Class&lt;?&gt; arrayClass);
 //返回数组中一个元素占用的大小
 public native int arrayIndexScale(Class&lt;?&gt; arrayClass);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li><li><blockquote><p>应用</p></blockquote><p>这两个与数据操作相关的方法，在<code>java.util.concurrent.atomic</code> 包下的<code>AtomicIntegerArray</code>（可以实现对Integer数组中每个元素的原子性操作）中有典型的应用</p></li></ul></li><li><p><strong>内存屏障</strong></p><ul><li><blockquote><p>主要包括</p></blockquote><ul><li>禁止load、store重排序</li></ul></li><li><blockquote><p>相关方法</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> //内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前
 public native void loadFence();
 //内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前
 public native void storeFence();
 //内存屏障，禁止load、store操作重排序
 public native void fullFence();
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li><li><blockquote><p>应用</p></blockquote><p>在JDK1.8中引入了一种锁的新机制--<code>StampedLock</code>，可以看成是读写锁的一个改进版本。<code>StampedLock</code>提供了一种乐观读锁的实现。</p><p>在<code>StampedLock.validate</code>方法的源码实现中，通过锁标记与相关常量进行位运算、比较来校验锁状态，在校验逻辑之前，会通过<code>Unsafe</code>的<code>loadFence</code>方法加入一个load内存屏障</p></li></ul></li><li><p><strong>系统相关</strong></p><ul><li><blockquote><p>主要包括</p></blockquote><ul><li>返回内存页大小</li><li>返回系统指针大小</li></ul></li><li><blockquote><p>相关方法</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> //返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。
 public native int addressSize();  
 //内存页的大小，此值为2的幂次方。
 public native int pageSize();
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li><li><blockquote><p>应用</p></blockquote><p><code>java.nio</code>下的工具类<code>Bits</code>中计算待申请内存所需内存页数量的静态方法，其依赖于<code>Unsafe</code>中<code>pageSize</code>方法获取系统内存页大小实现后续计算逻辑。</p></li></ul></li><li><p><strong>线程调度</strong></p><ul><li><blockquote><p>主要包括</p></blockquote><ul><li>线程挂起、恢复</li><li>获取、释放锁</li></ul></li><li><blockquote><p>相关方法</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> //取消阻塞线程
 public native void unpark(Object thread);
 //阻塞线程
 public native void park(boolean isAbsolute, long time);
 //获得对象锁（可重入锁）
 @Deprecated
 public native void monitorEnter(Object o);
 //释放对象锁
 @Deprecated
 public native void monitorExit(Object o);
 //尝试获取对象锁
 @Deprecated
 public native boolean tryMonitorEnter(Object o);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>方法<code>park</code>、<code>unpark</code>即可实现线程的挂起与恢复</p><p>将一个线程进行挂起是通过<code>park</code>方法实现的，调用<code>park</code>方法后，线程将一直阻塞直到超时或者中断等条件出现；</p><p><code>unpark</code>可以终止一个挂起的线程，使其恢复正常。</p></li><li><blockquote><p>应用</p></blockquote><p>Java锁和同步器框架的核心类<code>AbstractQueuedSynchronizer</code>，就是通过调用<code>LockSupport.park()</code>和<code>LockSupport.unpark()</code>实现线程的阻塞和唤醒的，而<code>LockSupport</code>的<code>park</code>、<code>unpark</code>方法实际是调用<code>Unsafe</code>的<code>park</code>、<code>unpark</code>方式来实现。</p></li></ul></li></ul><h3 id="unsafe的cas操作相关方法" tabindex="-1"><a class="header-anchor" href="#unsafe的cas操作相关方法" aria-hidden="true">#</a> Unsafe的CAS操作相关方法</h3><blockquote><p>我们又截取了部分<code>Unsafe</code>方法的源码，以下方法基本都是和「内存操作」相关的：</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> public final int getAndAddInt(Object var1, long var2, int var4) {
     int var5;
     do {
         var5 = this.getIntVolatile(var1, var2);
     } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
 ​
     return var5;
 }
 ​
 public final long getAndAddLong(Object var1, long var2, long var4) {
     long var6;
     do {
         var6 = this.getLongVolatile(var1, var2);
     } while(!this.compareAndSwapLong(var1, var2, var6, var6 + var4));
 ​
     return var6;
 }
 ​
 public final int getAndSetInt(Object var1, long var2, int var4) {
     int var5;
     do {
         var5 = this.getIntVolatile(var1, var2);
     } while(!this.compareAndSwapInt(var1, var2, var5, var4));
 ​
     return var5;
 }
 ​
 public final long getAndSetLong(Object var1, long var2, long var4) {
     long var6;
     do {
         var6 = this.getLongVolatile(var1, var2);
     } while(!this.compareAndSwapLong(var1, var2, var6, var4));
 ​
     return var6;
 }
 ​
 public final Object getAndSetObject(Object var1, long var2, Object var4) {
     Object var5;
     do {
         var5 = this.getObjectVolatile(var1, var2);
     } while(!this.compareAndSwapObject(var1, var2, var5, var4));
 ​
     return var5;
 }
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><p>从源码发现，<code>Unsafe</code>内部使用自旋的方式进行<code>CAS</code>更新（do-while循环）</p><p>并且可以发现，<code>Unsafe</code>类只提供了3种<code>CAS</code>方法：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> public final native boolean compareAndSwapObject(Object paramObject1, long paramLong, Object paramObject2, Object paramObject3);
 ​
 public final native boolean compareAndSwapInt(Object paramObject, long paramLong, int paramInt1, int paramInt2);
 ​
 public final native boolean compareAndSwapLong(Object paramObject, long paramLong1, long paramLong2, long paramLong3);
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>并且这几个方法都是<code>native</code>的。但是既然要剖析<code>Unsafe</code>类，我们就继续把它对应的C++代码挖出来。</p><h3 id="compareandswapint" tabindex="-1"><a class="header-anchor" href="#compareandswapint" aria-hidden="true">#</a> compareAndSwapInt</h3><blockquote><p>接上文我们知道<code>compareAndSwapInt</code>是一个<code>native</code>方法，这个<code>CAS</code>的实现在<code>unsafe.cpp</code>中</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))
   UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;);
   oop p = JNIHandles::resolve(obj);
   jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);
   return (jint)(Atomic::cmpxchg(x, addr, e)) == e;
 UNSAFE_END
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>它通过 <code>Atomic::cmpxchg</code> 来实现比较和替换操作。（其中参数x是即将更新的值，参数e是原内存的值。）</p><ul><li><blockquote><p><code>Atomic::cmpxchg</code>方法</p></blockquote><p>如果是Linux的x86，<code>Atomic::cmpxchg</code>方法的实现如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) {
   int mp = os::is_MP();
   __asm__ volatile (LOCK_IF_MP(%4) &quot;cmpxchgl %1,(%3)&quot;
                     : &quot;=a&quot; (exchange_value)
                     : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp)
                     : &quot;cc&quot;, &quot;memory&quot;);
   return exchange_value;
 }
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>如果是windows的x86，<code>Atomic::cmpxchg</code>方法的实现如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) {
     int mp = os::isMP(); //判断是否是多处理器
     _asm {
         mov edx, dest
         mov ecx, exchange_value
         mov eax, compare_value
         LOCK_IF_MP(mp)
         cmpxchg dword ptr [edx], ecx
     }
 }
 ​
 // Adding a lock prefix to an instruction on MP machine
 // VC++ doesn&#39;t like the lock prefix to be on a single line
 // so we can&#39;t insert a label after the lock prefix.
 // By emitting a lock prefix, we can define a label after it.
 #define LOCK_IF_MP(mp) __asm cmp mp, 0  \
                        __asm je L0      \
                        __asm _emit 0xF0 \
                        __asm L0:
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><ul><li><blockquote><p><code>os::is_MP()</code>作用</p></blockquote><p><code>mp</code>是<code>os::is_MP</code>的返回结果，<code>os::is_MP()</code>是一个内联函数，用来<strong>判断当前系统是否为多处理器。</strong></p><ul><li>如果当前系统是多处理器，该函数返回1。</li><li>否则，返回0。</li></ul></li><li><blockquote><p><code>LOCK_IF_MP(mp)</code>作用</p></blockquote><ul><li>如果是多处理器（<code>mp==1</code>），为<code>cmpxchg</code>指令添加<code>lock</code>前缀。</li><li>反之，就省略<code>lock</code>前缀（单处理器会不需要<code>lock</code>前缀提供的内存屏障效果）。</li></ul></li><li><blockquote><p><code>lock</code>前缀的作用？</p></blockquote><p>这里的<code>lock</code>前缀就是使用了处理器的总线锁（最新的处理器都使用缓存锁代替总线锁来提高性能）。</p><p>总得来说，它能保证<code>CAS</code>是一个原子操作，且还拥有内存屏障的作用，保证了<code>CAS</code>同时有<code>volatile</code>读和<code>volatile</code>写的内存语义。</p></li><li><blockquote><p><code>cmpxchg</code>整体作用</p></blockquote><p><code>cmpxchg(void* ptr, int old, int new)</code>，如果<code>ptr</code>和<code>old</code>的值一样，则把<code>new</code>写到<code>ptr</code>内存，否则返回<code>ptr</code>的值，整个操作是原子的。</p><p>在Intel平台下，会用<code>lock cmpxchg</code>来实现，使用<code>lock</code>触发缓存锁，这样另一个线程想访问<code>ptr</code>的内存，就会被<code>block</code>住。</p></li></ul></li></ul><h2 id="unsafe在atomic类中的应用" tabindex="-1"><a class="header-anchor" href="#unsafe在atomic类中的应用" aria-hidden="true">#</a> Unsafe在Atomic类中的应用</h2><blockquote><p>这里我们主要用<code>AtomicInteger</code>中对<code>Unsafe</code>调用实现的<code>CAS</code>操作源码来作为本章的内容：</p></blockquote><p><code>AtomicInteger</code>类的部分源码：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> public class AtomicInteger extends Number implements java.io.Serializable {
     private static final long serialVersionUID = 6214790243416807050L;
 ​
     // setup to use Unsafe.compareAndSwapInt for updates
     private static final Unsafe unsafe = Unsafe.getUnsafe();
     private static final long valueOffset;
 ​
     static {
         try {
             valueOffset = unsafe.objectFieldOffset
                 (AtomicInteger.class.getDeclaredField(&quot;value&quot;));
         } catch (Exception ex) { throw new Error(ex); }
     }
 ​
     private volatile int value;
     
     // ...
 }
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><ul><li><blockquote><p><code>Unsafe</code>的应用</p></blockquote><p><code>AtomicInteger</code>的实现中，静态字段<code>valueOffset</code>即为字段value的内存偏移地址，<code>valueOffset</code>的值在<code>AtomicInteger</code>初始化时，在静态代码块中通过<code>Unsafe</code>的<code>objectFieldOffset</code>方法获取。</p><p>在<code>AtomicInteger</code>中提供的线程安全方法中，通过字段<code>valueOffset</code>的值可以定位到<code>AtomicInteger</code>对象中value的内存地址，从而可以根据<code>CAS</code>实现对value字段的原子操作。</p></li><li><blockquote><p><code>AtomicInteger</code>自增操作</p></blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f26f00dac9624739950b04118ef68ce6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>上图为<code>AtomicInteger</code>对象自增操作前后的内存示意图</p><p>我们知道<code>CAS</code>需要知道3个参数：操作对象的内存地址，预期的值，要修改的值。</p><p>于是我们首先要获取的就是对象的内存地址</p><p>根据上面的图对象的基地址<code>baseAddress=“0x110000”</code>，通过<code>baseAddress+valueOffset</code>得到value的内存地址<code>valueAddress=“0x11000c”</code>；</p><p>然后通过<code>CAS</code>进行原子性的更新操作，成功则返回，否则继续重试，直到更新成功。这里预期值设置为1是成功的情况。</p></li></ul><h1 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h1><p>本章我们从乐观锁和悲观锁的介绍出发，然后概述了<code>CAS</code>，接着指出<code>Unsafe</code>类是Java的<code>CAS</code>操作实现的底层。</p><p>通过分析<code>Unsafe</code>类的源码，我们理解了它是一个不可或缺的Java底层类，用于许多与内存地址，<code>CAS</code>等相关操作。</p><p>本篇参考：</p><ul><li><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener noreferrer">https://tech.meituan.com/2018/11/15/java-lock.html</a></li><li><a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html" target="_blank" rel="noopener noreferrer">https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html</a></li><li><a href="http://www.cyc2018.xyz/Java/Java" target="_blank" rel="noopener noreferrer">http://www.cyc2018.xyz/Java/Java</a></li><li><a href="https://pdai.tech/md/java/thread/java-thread-x-juc-AtomicInteger.html" target="_blank" rel="noopener noreferrer">https://pdai.tech/md/java/thread/java-thread-x-juc-AtomicInteger.html</a></li></ul><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></footer><!----><!--[--><!--]--><!----></main><ul class="catalog" style="top:0px;"><li class="level-2 toc-link-乐观锁和悲观锁">乐观锁和悲观锁</li><li class="level-2 toc-link-什么是cas">什么是CAS？</li><li class="level-2 toc-link-cas操作流程">CAS操作流程</li><li class="level-2 toc-link-cas问题">CAS问题</li><li class="level-3 toc-link-aba问题">ABA问题</li><li class="level-3 toc-link-循环时间长开销大">循环时间长开销大</li><li class="level-3 toc-link-只能保证一个共享变量的原子操作">只能保证一个共享变量的原子操作</li><li class="level-2 toc-link-什么是unsafe类">什么是Unsafe类？</li><li class="level-2 toc-link-unsafe类源码">Unsafe类源码</li><li class="level-3 toc-link-unsafe的单例实现">Unsafe的单例实现</li><li class="level-3 toc-link-unsafe的api">Unsafe的API</li><li class="level-3 toc-link-unsafe的cas操作相关方法">Unsafe的CAS操作相关方法</li><li class="level-3 toc-link-compareandswapint">compareAndSwapInt</li><li class="level-2 toc-link-unsafe在atomic类中的应用">Unsafe在Atomic类中的应用</li></ul></div><!--]--></div><div class="search-page" role="search"><span class="search-close"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" width="28" height="28" fill="currentColor"><path d="M224 416c-8.188 0-16.38-3.125-22.62-9.375l-192-192c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L224 338.8l169.4-169.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-192 192C240.4 412.9 232.2 416 224 416z"></path></svg></span><div class="gungnir-search-box"><input placeholder="$ grep ..." autocomplete="off" spellcheck="false" value><!----></div></div><div class="menu-btn-container"><div class="menu-btn-wrapper"><div class="menu-btn"><div style="" class="menu-btn-icon"><span></span><span></span><span></span></div><div style="display:none;" class="menu-text">0</div><svg class="menu-progress"><circle class="menu-border" cx="50%" cy="50%" r="48%" style="stroke-dasharray:0% 314.15926%;"></circle></svg></div><div class="menu-btn-child-wrapper"><div class="toggle-dark-button menu-btn-child" title="toggle dark mode"><svg class="ov-icon" style="font-size:1.2em;display:none;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"/></svg><svg class="ov-icon" style="font-size:1.2em;display:none;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 00283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"/></svg><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M224 96l16-32 32-16-32-16-16-32-16 32-32 16 32 16 16 32zM80 160l26.66-53.33L160 80l-53.34-26.67L80 0 53.34 53.33 0 80l53.34 26.67L80 160zm352 128l-26.66 53.33L352 368l53.34 26.67L432 448l26.66-53.33L512 368l-53.34-26.67L432 288zm70.62-193.77L417.77 9.38C411.53 3.12 403.34 0 395.15 0c-8.19 0-16.38 3.12-22.63 9.38L9.38 372.52c-12.5 12.5-12.5 32.76 0 45.25l84.85 84.85c6.25 6.25 14.44 9.37 22.62 9.37 8.19 0 16.38-3.12 22.63-9.37l363.14-363.15c12.5-12.48 12.5-32.75 0-45.24zM359.45 203.46l-50.91-50.91 86.6-86.6 50.91 50.91-86.6 86.6z"/></svg></div><div class="menu-btn-child"><svg class="ov-icon" style="font-size:1.7999999999999998em;" aria-hidden="true" width="28.799999999999997" height="28.799999999999997" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"/></svg></div><div class="menu-btn-child"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M240.971 130.524l194.343 194.343c9.373 9.373 9.373 24.569 0 33.941l-22.667 22.667c-9.357 9.357-24.522 9.375-33.901.04L224 227.495 69.255 381.516c-9.379 9.335-24.544 9.317-33.901-.04l-22.667-22.667c-9.373-9.373-9.373-24.569 0-33.941L207.03 130.525c9.372-9.373 24.568-9.373 33.941-.001z"/></svg></div><div class="menu-btn-child menu-toc-btn"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M48 48a48 48 0 1048 48 48 48 0 00-48-48zm0 160a48 48 0 1048 48 48 48 0 00-48-48zm0 160a48 48 0 1048 48 48 48 0 00-48-48zm448 16H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16v-32a16 16 0 00-16-16zm0-320H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16V80a16 16 0 00-16-16zm0 160H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16v-32a16 16 0 00-16-16z"/></svg></div><div class="toggle-sidebar-button menu-btn-child menu-btn-sidebar" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-1.6 -1.6 19.2 19.2" fill="currentColor"><path d="M14 2a1 1 0 011 1v10a1 1 0 01-1 1H2a1 1 0 01-1-1V3a1 1 0 011-1h12zM2 1a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V3a2 2 0 00-2-2H2z"/><path d="M3 4a1 1 0 011-1h2a1 1 0 011 1v8a1 1 0 01-1 1H4a1 1 0 01-1-1V4z"/></svg></div></div></div></div><footer class="footer"><span>
                &copy; pixel-revolve 2021-2022
                <br>
                Powered by <a href="https://vuepress.vuejs.org" target="_blank">VuePress</a> &
                <a href="https://github.com/Renovamen/vuepress-theme-gungnir" target="_blank">Gungnir</a>
                </span></footer></div><!--]--></div>
    <script type="module" src="/assets/app.9fd9aa02.js" defer></script>
  </body>
</html>
