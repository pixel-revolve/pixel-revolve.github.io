<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.38">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/img/logo-broccoli.png"><title>绕不开的并发编程--volatile原理 | pixel-revolve</title><meta name="description" content="爱编程，爱生活">
    <link rel="modulepreload" href="/assets/app.9fd9aa02.js"><link rel="modulepreload" href="/assets/index.html.61e78e64.js"><link rel="modulepreload" href="/assets/index.html.0c215270.js">
    <link rel="stylesheet" href="/assets/style.2781e754.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container no-sidebar"><!--[--><header class="navbar invert"><span><a href="/" class=""><span class="site-name">$ cd /home/</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="Home"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/></svg></span><span>Home</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/tags/" class="" aria-label="Tags"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M17.707 9.293a1 1 0 010 1.414l-7 7a1 1 0 01-1.414 0l-7-7A.997.997 0 012 10V5a3 3 0 013-3h5c.256 0 .512.098.707.293l7 7zM5 6a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/></svg></span><span>Tags</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/links/" class="" aria-label="Links"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z" clip-rule="evenodd"/></svg></span><span>Links</span><!--[--><!--]--></a></div><!--]--><div class="navbar-item"><a style="cursor:pointer;"><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 2c4.968 0 9 4.032 9 9s-4.032 9-9 9-9-4.032-9-9 4.032-9 9-9zm0 16c3.867 0 7-3.133 7-7 0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7zm8.485.071l2.829 2.828-1.415 1.415-2.828-2.829 1.414-1.414z"/></svg></span><span>Search</span></a></div></nav><!--[--><!--]--><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="Home"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/></svg></span><span>Home</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/tags/" class="" aria-label="Tags"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M17.707 9.293a1 1 0 010 1.414l-7 7a1 1 0 01-1.414 0l-7-7A.997.997 0 012 10V5a3 3 0 013-3h5c.256 0 .512.098.707.293l7 7zM5 6a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/></svg></span><span>Tags</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/links/" class="" aria-label="Links"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z" clip-rule="evenodd"/></svg></span><span>Links</span><!--[--><!--]--></a></div><!--]--><div class="navbar-item"><a style="cursor:pointer;"><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 2c4.968 0 9 4.032 9 9s-4.032 9-9 9-9-4.032-9-9 4.032-9 9-9zm0 16c3.867 0 7-3.133 7-7 0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7zm8.485.071l2.829 2.828-1.415 1.415-2.828-2.829 1.414-1.414z"/></svg></span><span>Search</span></a></div></nav><!--[--><!--]--><!----><!--[--><!--]--></aside><!--]--><div class="page-content"><!--[--><div class="show-catalog post-wrapper"><div class="article-header use-image post-header" style="background-image:url(/img/blog_cover/2022/11/绕不开的并发编程--volatile原理.jpg);"><div class="article-header-mask" style="background:rgba(40, 57, 101, .4);"></div><div class="article-header-content"><div class="article-tags"><!--[--><span class="article-tag">并发编程</span><!--]--></div><h1 class="article-title">绕不开的并发编程--volatile原理</h1><p class="article-subtitle">synchronized的一种轻量级的实现，读写操作都是无锁的</p><div class="article-icons"><div class="article-icon"><svg class="ov-icon" style="font-size:1.08em;" aria-hidden="true" width="17.28" height="17.28" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M313.6 304c-28.7 0-42.5 16-89.6 16-47.1 0-60.8-16-89.6-16C60.2 304 0 364.2 0 438.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-25.6c0-74.2-60.2-134.4-134.4-134.4zM400 464H48v-25.6c0-47.6 38.8-86.4 86.4-86.4 14.6 0 38.3 16 89.6 16 51.7 0 74.9-16 89.6-16 47.6 0 86.4 38.8 86.4 86.4V464zM224 288c79.5 0 144-64.5 144-144S303.5 0 224 0 80 64.5 80 144s64.5 144 144 144zm0-240c52.9 0 96 43.1 96 96s-43.1 96-96 96-96-43.1-96-96 43.1-96 96-96z"/></svg><span>pixel-revolve</span></div><div class="article-icon"><svg class="ov-icon" style="font-size:1.08em;" aria-hidden="true" width="17.28" height="17.28" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M400 64h-48V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H160V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zm-6 400H54c-3.3 0-6-2.7-6-6V160h352v298c0 3.3-2.7 6-6 6z"/></svg><span>2022-11-07</span></div><div class="article-icon"><svg class="ov-icon" style="font-size:1.08em;" aria-hidden="true" width="17.28" height="17.28" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M17.618 5.968l1.453-1.453 1.414 1.414-1.453 1.453a9 9 0 11-1.414-1.414zM12 20a7 7 0 100-14 7 7 0 000 14zM11 8h2v6h-2V8zM8 1h8v2H8V1z"/></svg><span>28 min</span></div></div></div><!----></div><main class="page post-content"><!--[--><!--]--><div class="theme-gungnir-content"><!--[--><h1 id="简单介绍" tabindex="-1"><a class="header-anchor" href="#简单介绍" aria-hidden="true">#</a> 简单介绍</h1><h2 id="jmm的设计" tabindex="-1"><a class="header-anchor" href="#jmm的设计" aria-hidden="true">#</a> JMM的设计</h2><blockquote><p><code>JMM</code>的设计意图</p></blockquote><ul><li><p><strong>我们程序员写代码时，是要求内存模型易于理解，易于编程。</strong></p><p>所以我们需要依赖一个强内存模型来编码。 也就是说像公理一样，定义好的规则，我们遵守规则写代码就完事了。</p></li><li><p><strong>对于编译器和处理器的实现来说，它们希望约束尽量少一些。</strong></p><p>毕竟你限制它们肯定影响它们的执行效率，不能让他们尽己所能的优化来提供性能。所以他们需要一个弱内存模型。</p></li></ul><p>于是根据上面两点我们知道，作为程序员我们希望<code>JMM</code>提供给我们一个强内存模型，而底层的编译器和处理器又需要一个弱内存模型来提高自己的性能。</p><p>在计算机领域，这种需要权衡的场景非常多，比如内存和CPU寄存器，就引入了CPU多级缓存来解决性能问题，不过也引入了多核CPU并发场景下的各种问题。</p><p>所以这里也一样，<strong>我们需要找到一个平衡点，来满足程序员的需求，同时也尽可能满足编译器和处理器限制放松，性能最大化。</strong></p><ul><li><blockquote><p>因此<code>JMM</code>在设计时，定义了如下策略：</p></blockquote><ul><li>对于<strong>会改变程序执行结果的重排序</strong>，<code>JMM</code>要求编译器和处理器<strong>必须禁止</strong>这种重排序。</li><li>对于<strong>不会改变程序执行结果的重排序</strong>，<code>JMM</code>对编译器和处理器<strong>不做要求</strong>（<code>JMM</code>允许这种重排序）。</li></ul><p>通过这样的策略<code>JMM</code>向程序员提供了<strong>足够强的的内存可见性保证</strong>，在不影响程序执行结果的情况下，有些可见性保证并一定存在。</p><p>比如说下面的程序：<code>A happens-before B</code> 并不保证，因为其不影响程序执行结果：</p><div class="language-cpp ext-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span> <span class="token comment">// A</span>
<span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span> <span class="token comment">// B</span>
<span class="token keyword">double</span> area <span class="token operator">=</span> pi <span class="token operator">*</span> r <span class="token operator">*</span> r<span class="token punctuation">;</span> <span class="token comment">// C</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这就引出了另一个方面，<code>JMM</code>为了满足编译器和处理器的约束尽可能少，它遵循的规则是：<strong>只要不改变程序的执行结果，编译器和处理器想怎么优化就怎么优化</strong>。</p><ul><li><blockquote><p>例子</p></blockquote><ul><li>锁消除：如果编译器认定一个锁只有可能被单个线程访问，那么这个锁可以被消除。</li><li>编译器认定一个<code>volatile</code>变量只会被单个线程访问，那么编译器可以把这个<code>volatile</code>变量当作一个普通变量来对待。</li><li>...</li></ul></li></ul></li></ul><blockquote><p><code>JMM</code>的设计</p></blockquote><p><strong><code>JMM</code>的设计分为两部分</strong>：</p><ul><li>一部分是<strong>面向我们程序员</strong>提供的，也就是<code>happens-before</code>规则，它通俗易懂的向我们程序员阐述了一个强内存模型，<strong>我们只要理解 <code>happens-before</code>规则，就可以编写并发安全的程序了。</strong></li><li>另一部分是<strong>针对<code>JVM</code>实现的</strong>，为了尽可能少的对编译器和处理器做约束，从而提高性能，<code>JMM</code>在不影响程序执行结果的前提下对其不做要求，即允许优化重排序。</li></ul><h2 id="happens-before原则" tabindex="-1"><a class="header-anchor" href="#happens-before原则" aria-hidden="true">#</a> happens-before原则</h2><blockquote><p><code>happens-before</code>是<code>JMM</code>最核心的概念。对于Java程序员来说，理解<code>happens-before</code>是理解<code>JMM</code>的关键。</p></blockquote><p>我们知道<code>JMM</code>是为了解决在并发环境下由于 CPU缓存、编译器和处理器的指令重排序导致的可见性、有序性问题。</p><p>通过学习<code>volatile</code>的内存语义实现原理我们会知道，<code>JMM</code>解决指令重排其实是因为它定义了一项<code>happens-before</code>原则。</p><blockquote><p>如何理解<code>happens-before</code>原则呢？</p></blockquote><p><code>happens-before</code> 表达的<strong>并不是说前面一个操作发生在后面一个操作的前面</strong>，尽管从程序员编程角度来看也并不会出错，但它其实表达的是，<strong>前一个操作的结果对后续操作时可见的</strong>。</p><p><code>JMM</code>为程序员提供的视角就是按顺序执行的，且满足一个操作 <code>happens-before</code> 于另一个操作，那么**第一个操作的执行结果将对第二个执行结果可见，而且第一个操作的执行顺序排在第二个顺序之前。**注意，这是 <strong><code>JMM</code>向程序员做出的保证</strong>。</p><p>但是其实<code>JMM</code>在对编译器和处理器进行约束时，如前面所说遵循的规则是在<strong>不改变程序执行的结果的前提下，编译器和处理器如何优化都可以。</strong></p><p>意思就是说即使两个操作之间存在 <code>happens-before</code>原则，Java平台也<strong>不一定会按照规则定义的顺序来执行</strong>。这么做的原因是因为程序员并不关心两个操作是否被重排序，只要保证程序执行时语义不被改变就行了。</p><p><strong><code>happens-before</code>这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</strong></p><blockquote><p>具体的<code>happens-before</code>规则定义</p></blockquote><ul><li><p><strong>程序顺序规则</strong></p><p><strong>一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作</strong>。这个还是非常好理解的，比如上面那三行代码，A <code>happens-before</code> 于 B，这就是规则1的内容，比较符合单线程里面的逻辑思维，很好理解。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span> <span class="token comment">// A</span>
<span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span> <span class="token comment">// B</span>
<span class="token keyword">double</span> area <span class="token operator">=</span> pi <span class="token operator">*</span> r <span class="token operator">*</span> r<span class="token punctuation">;</span> <span class="token comment">// C</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p><strong>监视器锁规则</strong></p><p>对于一个锁的解锁，<code>happens-before</code>于随后对这个锁的加锁</p><p>例如下面的代码，在进入同步块之前，会自动加锁，而在代码块执行完会自动释放锁，加锁以及释放锁都是编译器帮我们实现的。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//此处自动加锁</span>
  <span class="token comment">// x是共享变量,初始值=10</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>  
<span class="token punctuation">}</span> <span class="token comment">//此处自动解锁</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li><li><p><strong><code>volatile</code>变量规则</strong></p><p><strong>对一个volatile域的写，happens-before于任意后续对这个volatile域的读</strong></p><p>关于这一点我们可以关联下一点「传递性」来理解。</p></li><li><p><strong>传递性</strong></p><p><strong>如果A happens-before B，且B happens-before C，那么A happens-before C。</strong></p><p>我们将传递性应用到我们下面的例子中</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">VolatileExample</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> v <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    v <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 这里x会是多少呢？</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>可以看下面这幅图：</p><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221101150236901.png" alt="image-20221101150236901"></p><p>从图中我们可以看到：</p><ul><li>『x=42』 <code>Happens-Before</code> 写变量 『v=true』 ，这是规则 「程序顺序规则」 的内容；</li><li>写变量『v=true』 <code>Happens-Before</code> 读变量 『v=true』，这是规则 「<code>volatile</code>变量规则」 的内容 。</li><li>再根据这个传递性规则，我们得到结果：『x=42』 <code>Happens-Before</code> 读变量『v=true』。这意味着什么呢？</li></ul><p>如果线程 B 读到了『v=true』，那么线程 A 设置的『x=42』对线程 B 是可见的。</p><p>也就是说，<strong>线程 B 能看到 『x == 42』</strong> ，有没有一种恍然大悟的感觉？这就是 1.5 版本对 <code>volatile</code> 语义的增强，这个增强意义重大，1.5 版本的并发工具包（<code>java.util.concurrent</code>）就是靠 <code>volatile</code> 语义来搞定可见性的。</p></li><li><p><strong><code>start()</code>规则</strong></p><p><strong>这条是关于线程启动的。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程A在启动子线程 B 前的操作。</strong></p></li><li><p><strong><code>join()</code>规则</strong></p><p><strong>如果线程A执行操作<code>ThreadB.join()</code>并成功返回，那么线程B中的任意操作<code>happens-before</code>于线程A从<code>ThreadB.join()</code>操作成功返回。</strong></p></li></ul><p>通过上面6种<code>happens-before</code>规则的组合就能为我们程序员提供一致的内存可见性。<strong>最常用的就是「程序顺序规则」和其他规则结合，为我们编写并发程序提供可靠的内存可见性模型。</strong></p><h1 id="volatile原理" tabindex="-1"><a class="header-anchor" href="#volatile原理" aria-hidden="true">#</a> volatile原理</h1><blockquote><p>volatile有什么用？</p></blockquote><ul><li><blockquote><p>防重排序</p></blockquote><p>用一个经典的单例模式--双重检查加锁（<code>DCL</code>）实现来分析重排序问题：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>我们为什么要在变量<code>singleton</code>前面加上<code>volatile</code>关键字呢？</p><p>我们知道实例化一个对象其实可以分成三个步骤：</p><ul><li>分配内存空间</li><li>初始化对象</li><li>将内存空间的地址赋值给对应的引用</li></ul><p>但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会编程如下过程：</p><ul><li>分配内存空间</li><li>将内存空间的地址赋值给对应的引用</li><li>初始化对象</li></ul><p>如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变脸设置成<code>volatile</code>类型的变量。</p></li><li><blockquote><p>实现可见性</p></blockquote><p>可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区--线程工作内存。<code>volatile</code>关键字能有效的解决这个问题。</p></li></ul><blockquote><p><code>happens-before</code>原则的本质</p></blockquote><p>通过上面我们的了解，我们知道了<code>happens-before</code>的语义本质是一种可见性，A <code>Happens-before</code> B 意味着 <strong>A 事件对 B 事件来说是可见的，无论 A 事件和 B 事件是否发生在同一个线程里。</strong></p><blockquote><p>于是通过上面的分析我们知道了<code>volatile</code>关键字主要是实现了并发编程中的可见性和有序性，于是接着我们就围绕这两个特性的实现来说明<code>volatile</code>原理</p></blockquote><h2 id="volatile可见性实现原理" tabindex="-1"><a class="header-anchor" href="#volatile可见性实现原理" aria-hidden="true">#</a> volatile可见性实现原理</h2><blockquote><p>volatile变量的内存可见性是基于内存屏障（Memory Barrier）实现的</p></blockquote><ul><li><blockquote><p>什么是内存屏障</p></blockquote><p>内存屏障，又称内存栅栏，<strong>是一个CPU指令</strong>（后面我们会知道就是<code>lock</code>指令）</p><p>在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序</p><p><code>JMM</code> 为了保证在不同的编译器和 CPU 上有相同的结果，<strong>通过插入特定类型的内存屏障来禁止 + 特定类型的编译器重排序和处理器重排序</strong>，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 <code>Memory Barrier</code> 指令重排序</p></li><li><blockquote><p>lock指令</p></blockquote><p>我们写一段简单的Java代码，声明一个<code>volatile</code>变量，并且赋值。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        test<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>通过<code>hsdis</code>和<code>jitwatch</code>工具可以获得编译后的汇编代码：</p><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221107103200062.png" alt="image-20221107103200062"></p><p>在<code>volatile</code>修饰的共享变量<strong>进行写操作的时候</strong>会多出<code>lock</code>前缀的指令</p><ul><li><blockquote><p>什么是lock指令？</p></blockquote><p>在 Pentium 和早期的 IA-32 处理器中，<code>lock</code> 前缀会使处理器执行当前指令时产生一个 <code>LOCK#</code> 信号，会对总线进行锁定，其它 CPU 对内存的读写请求都会被阻塞，直到锁释放。</p><p>后来的处理器，加锁操作是由高速缓存锁代替总线锁来处理。 因为锁总线的开销比较大，锁总线期间其他 CPU 没法访问内存。 这种场景多缓存的数据一致通过缓存一致性协议(<code>MESI</code>)来保证。</p></li><li><blockquote><p>什么是缓存一致性协议？</p></blockquote><p><strong>缓存是分段(line)的，一个段对应一块存储空间，称之为缓存行</strong>，它是 CPU 缓存中可分配的最小存储单元，大小 32 字节、64 字节、128 字节不等，这与 CPU 架构有关，通常来说是 64 字节。</p><p><code>LOCK#</code> 因为锁总线效率太低，因此使用了多组缓存。 为了使其行为看起来如同一组缓存那样。因而设计了「缓存一致性协议」。</p><p>缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 &quot; 嗅探(snooping)&quot; 协议。</p><p>所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。 缓存本身是独立的，但是内存是共享资源，<strong>所有的内存访问都要经过仲裁</strong>(同一个指令周期中，只有一个 CPU 缓存可以读写内存)。 CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是<strong>不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么</strong>。</p><p><strong>当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。</strong></p></li><li><blockquote><p>lock指令有什么用？</p></blockquote><p><code>lock</code>前缀的指令在多核处理器下会引发两件事情：</p><ul><li><p><strong>将当前处理器缓存行的数据写回到系统内存</strong></p><p>为了提高处理速度，处理器不直接和内存进行通信，而是<strong>先将系统内存的数据读到内部缓存</strong>（<code>L1</code>，<code>L2</code> 或其它）后再进行操作，但操作不知道何时会写到内存。</p><p>如果对声明了<code>volatile</code>的变量进行写操作，<code>JVM</code>就会向处理器发送一条<code>lock</code>前缀的指令，将这个变量所在的数据<strong>写回到系统内存。</strong></p></li><li><p><strong>写回内存的操作会使在其它CPU里缓存了该内存地址的数据无效</strong></p><p>为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(<code>MESI</code>)，每个处理器通过<strong>嗅探在总线上传播的数据来检查自己缓存的值是不是过期了</strong>，当处理器发现自己缓存行对应的内存地址被修改，就会<strong>将当前处理器的缓存行设置成无效状态</strong>，当处理器对这个数据进行修改操作的时候，<strong>会重新从系统内存中把数据读到处理器缓存里</strong>。</p><p>所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</p></li></ul><p><code>volatile</code> 变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p></li></ul></li></ul><p>通过内存屏障当前处理器的工作内存的变量内容会写回到主内存中，这样一来就保证了可见性。</p><h2 id="volatile有序性实现原理" tabindex="-1"><a class="header-anchor" href="#volatile有序性实现原理" aria-hidden="true">#</a> volatile有序性实现原理</h2><blockquote><p>volatile和happens-before原则的关系</p></blockquote><p><code>happens-before</code>规则中有一条是<code>volatile</code>变量规则：</p><p>对一个<code>volatile</code>域的写，<code>happens-before</code>于任意后续对这个<code>volatile</code>域的读。</p><p>为了具体描述这个规则，我们编写一段代码，假设线程A执行writer方法，线程B执行reader方法：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 假设线程A执行writer方法，线程B执行reader方法</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VolatileExample2</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>              <span class="token comment">// 1 线程A修改共享变量</span>
        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">// 2 线程A写volatile变量</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment">// 3 线程B读同一个volatile变量</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> a<span class="token punctuation">;</span>          <span class="token comment">// 4 线程B读共享变量</span>
        <span class="token comment">// ……</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>根据<code>happens-before</code>规则，上述过程会建立3类<code>happens-before</code>关系：</p><ul><li>根据程序次序规则：1 <code>happens-before</code> 2 且 3 <code>happens-before</code> 4</li><li>根据 <code>volatile</code> 规则：2 <code>happens-before</code> 3</li><li>根据 <code>happens-before</code> 的传递性规则：1 <code>happens-before</code> 4</li></ul><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221107135010073.png" alt="image-20221107135010073"></p><p>因为以上规则，当线程 A 将 <code>volatile</code> 变量 <code>flag</code> 更改为 <code>true</code> 后，线程 B 能够迅速感知。</p><blockquote><p>volatile禁止重排序</p></blockquote><p>为了性能优化，<code>JMM</code> 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。<code>JMM</code> 提供了内存屏障阻止这种重排序。</p><p>Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p><p><code>JMM</code> 会针对编译器制定 <code>volatile</code> 重排序规则表：</p><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221107140107525.png" alt="image-20221107140107525"></p><p>这里的『NO』表示禁止重排序。表示的是第一个操作是XX，第二个操作是YY的时候会不会插入内存屏障来禁止重排序。</p><ul><li><blockquote><p>内存屏障分类</p></blockquote><table><thead><tr><th>内存屏障</th><th>说明</th></tr></thead><tbody><tr><td>StoreStore 屏障</td><td>禁止上面的普通写和下面的 volatile 写重排序</td></tr><tr><td>StoreLoad 屏障</td><td>防止上面的 volatile 写与下面可能有的 volatile 读/写重排序</td></tr><tr><td>LoadLoad 屏障</td><td>禁止下面所有的普通读操作和上面的 volatile 读重排序</td></tr><tr><td>LoadStore 屏障</td><td>禁止下面所有的普通写操作和上面的 volatile 读重排序</td></tr></tbody></table><p>为了实现 <code>volatile</code> 内存语义时，<strong>编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</strong></p><p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，<code>JMM</code> 采取了保守的策略：</p><ul><li><p>对于 <code>volatile</code> 写操作</p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221107142030004.png" alt="image-20221107142030004" style="zoom:50%;"><ul><li><p>在每个 <code>volatile</code> 写操作的前面插入一个 <code>StoreStore</code> 屏障。</p></li><li><p>在每个 <code>volatile</code> 写操作的后面插入一个 <code>StoreLoad</code> 屏障。</p></li></ul></li><li><p>对于 <code>volatile</code> 读操作</p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221107142630049.png" alt="image-20221107142630049" style="zoom:50%;"><ul><li><p>在每个 <code>volatile</code> 读操作的后面插入一个 <code>LoadLoad</code> 屏障。</p></li><li><p>在每个 <code>volatile</code> 读操作的后面插入一个 <code>LoadStore</code> 屏障。</p></li></ul></li></ul><p><code>volatile</code> 写是在前面和后面分别插入内存屏障，而 <code>volatile</code> 读操作是在后面插入两个内存屏障。</p><p>基本上就是这几类的内存屏障中和普通读写的规则再加上 <code>volatile</code> 读/写操作互相禁止重排序，就是这几个操作的顺序规则了。</p></li></ul><p>于是<code>volatile</code>有序性基于内存屏障来禁止指令重排，再加上<code>JMM</code>本身制定的<code>happens-before</code>保证了有序性。</p><h1 id="volatile使用" tabindex="-1"><a class="header-anchor" href="#volatile使用" aria-hidden="true">#</a> volatile使用</h1><blockquote><p>volatile关键字的两层语义</p></blockquote><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被<code>volatile</code>修饰之后，那么就具备了两层语义：</p><ul><li><p>保证了不同线程对这个变量进行操作时的可见性</p><p>即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p></li><li><p>禁止进行指令重排序。</p></li></ul><p>我们不难发现这两个语义也就是我们上面说的可见性和有序性。但是将语义赋给共享变量更符合我们编程的时候的思考方式。</p><p>为了描述这两个语义更加具体，我们会看两个例子</p><ul><li><blockquote><p>可见性语义场景</p></blockquote><p>假如线程1先执行，线程2后执行：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//线程1</span>
<span class="token keyword">boolean</span> stop <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stop<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token comment">//线程2</span>
stop <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>很多人中断线程时可能都会采用这种标记办法。</p><ul><li><blockquote><p>但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？</p></blockquote><p>不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p><p>每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将<code>stop</code>变量的值拷贝一份放在自己的工作内存当中。</p><p>那么<strong>当线程2更改了<code>stop</code>变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了</strong>，那么线程1<strong>由于不知道线程2对<code>stop</code>变量的更改</strong>，因此还会一直循环下去。</p></li><li><blockquote><p>那么加上volatile修饰会有什么不同？</p></blockquote><p>分析这个问题实际就是给这个共享变量增加上述的描述可见性的语义，然后加以推导：</p><ul><li><p>使用<code>volatile</code>关键字会<strong>强制将修改的值立即写入主存；</strong></p></li><li><p>使用<code>volatile</code>关键字的话，<strong>当线程2进行修改时，会导致线程1的工作内存中缓存变量<code>stop</code>的缓存行无效</strong>（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p><p>由于线程1的工作内存中缓存变量<code>stop</code>的缓存行无效，所以线程1再次读取变量<code>stop</code>的值时会去主存读取。</p></li></ul><p>那么线程1读取到的就是最新的正确的值。</p></li></ul></li><li><blockquote><p>禁止指令重排语义场景</p></blockquote><p><code>volatile</code>关键字禁止指令重排序的语义再扩展一下的话有两层意思：</p><ul><li><p><strong>当程序执行到<code>volatile</code>变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</strong></p><p>（相当于对程序员的承诺）</p></li><li><p>在进行指令优化时，不能将在对<code>volatile</code>变量访问的语句放在其后面执行，也不能把<code>volatile</code>变量后面的语句放到其前面执行。</p><p>（相当于对编译器的要求）</p></li></ul><p>举一个简单的例子：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//x、y为非volatile变量</span>
<span class="token comment">//flag为volatile变量</span>
 
x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment">//语句1</span>
y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//语句2</span>
flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">//语句3</span>
x <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>         <span class="token comment">//语句4</span>
y <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token comment">//语句5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>由于<code>flag</code>变量为<code>volatile</code>变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p><p>并且<code>volatile</code>关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p><p>再来一个例子，这次真正的用禁止重排序解决问题：</p><p>这里线程1先执行，线程2也随后立刻开始执行</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">//线程1:</span>
context <span class="token operator">=</span> <span class="token function">loadContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//语句1</span>
inited <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>             <span class="token comment">//语句2</span>
 
<span class="token comment">//线程2:</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>inited <span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">doSomethingwithconfig</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li><blockquote><p>指令重排让语句2在语句1前执行会有什么问题？</p></blockquote><p>有可能语句2会在语句1之前执行，那么就可能导致<code>context</code>还没被初始化，而线程2中就使用未初始化的<code>context</code>去进行操作，导致程序出错。</p></li><li><blockquote><p>用了volatile会有什么不同？</p></blockquote><p>这里如果用<code>volatile</code>关键字对<code>inited</code>变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证<code>context</code>已经初始化完毕。（就像一个屏障一样）</p></li></ul></li></ul><blockquote><p>使用volatile必须具备的条件</p></blockquote><p><code>synchronized</code>关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而<code>volatile</code>关键字在某些情况下性能要优于<code>synchronized</code>，但是要注意<code>volatile</code>关键字是无法替代<code>synchronized</code>关键字的，因为<code>volatile</code>关键字无法保证操作的原子性。</p><p>通常来说，使用<code>volatile</code>必须具备以下几个条件：</p><ul><li>对变量的写操作不依赖于当前值。</li><li>该变量没有包含在具有其他变量的不变式中。</li><li>只有在状态真正独立于程序内其他内容时才能使用 <code>volatile</code>。</li></ul><p>实际上，这些条件表明，可以被写入 <code>volatile</code> 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p><p>事实上，上面的几个条件需要保证操作是原子性操作，才能保证使用<code>volatile</code>关键字的程序在并发时能够正确执行。</p><blockquote><p>volatile的应用场景</p></blockquote><ul><li><blockquote><p>一. 状态标志</p></blockquote><p>也许实现 <code>volatile</code> 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">volatile</span> <span class="token keyword">boolean</span> shutdownRequested<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> shutdownRequested <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>shutdownRequested<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token comment">// do stuff</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这里即使用<code>shutdownRequested</code>来做状态标志位，一旦被其他线程修改(<code>shutdown</code>)，<code>doWork</code>程序就会结束。</p></li><li><blockquote><p>二. 一次性安全发布(one-time safe publication)</p></blockquote><p>缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原始值变得更加困难。</p><p><strong>在缺乏同步的情况下，可能会遇到某个对象引用的更新值（由另一个线程写入）和该对象状态的旧值同时存在。</strong>(这就是造成著名的双重检查锁定(double-checked-locking)问题的根源，<strong>其中对象引用在没有同步的情况下进行读操作</strong>，产生的问题是您<strong>可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象</strong>)。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BackgroundFloobleLoader</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token class-name">Flooble</span> theFlooble<span class="token punctuation">;</span>
 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initInBackground</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// do lots of stuff</span>
        theFlooble <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Flooble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// this is the only write to theFlooble</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SomeOtherClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            <span class="token comment">// do some stuff...</span>
            <span class="token comment">// use the Flooble, but only if it is ready</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>floobleLoader<span class="token punctuation">.</span>theFlooble <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> 
                <span class="token function">doSomething</span><span class="token punctuation">(</span>floobleLoader<span class="token punctuation">.</span>theFlooble<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p><code>doWork</code>在真正用<code>floobleLoader.theFlooble</code>去<code>doSometing</code>之前先进行一次对象引用是否为空的检查。</p><p>只有被另一个线程修改并发布(<code>volatile</code>强制修改后写回主存的语义)，才会执行，保证了操作的安全。（不会出现对象引用的更新值<code>new Flooble()</code>和旧值<code>null</code>同时存在的可能）</p></li><li><blockquote><p>三. 独立观察(independent observation)</p></blockquote><p>安全使用 <code>volatile</code> 的另一种简单模式是<strong>定期 发布 观察结果供程序内部使用。</strong></p><p>例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 <code>volatile</code> 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">EnvironmentalSensor</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">double</span> temperature<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setTemperature</span><span class="token punctuation">(</span><span class="token keyword">double</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
        temperature<span class="token operator">=</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">getTemperature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> temperature<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readAndModifyTemperature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置暂停的时间 5 秒</span>
            <span class="token class-name">EnvironmentalSensor</span><span class="token punctuation">.</span><span class="token function">setTemperature</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">watchNewTemperature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">EnvironmentalSensor</span><span class="token punctuation">.</span><span class="token function">getTemperature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div></li><li><blockquote><p>四. volatile bean 模式</p></blockquote><p>在 <code>volatile bean</code> 模式中，<code>JavaBean</code> 的所有数据成员都是 <code>volatile</code> 类型的，并且 <code>getter</code> 和 <code>setter</code> 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。</p><p>此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为 <code>volatile</code> 时，只有引用而不是数组本身具有 <code>volatile</code> 语义)。对于任何 <code>volatile</code> 变量，不变式或约束都不能包含 <code>JavaBean</code> 属性。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@ThreadSafe</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">String</span> firstName<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">String</span> lastName<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
 
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getFirstName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> firstName<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getLastName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> lastName<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> age<span class="token punctuation">;</span> <span class="token punctuation">}</span>
 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFirstName</span><span class="token punctuation">(</span><span class="token class-name">String</span> firstName<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">this</span><span class="token punctuation">.</span>firstName <span class="token operator">=</span> firstName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLastName</span><span class="token punctuation">(</span><span class="token class-name">String</span> lastName<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">this</span><span class="token punctuation">.</span>lastName <span class="token operator">=</span> lastName<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div></li><li><blockquote><p>五. 开销较低的读 - 写锁策略</p></blockquote><p><code>volatile</code> 的功能还不足以实现计数器。因为 <code>++x</code> 实际上是三种操作(读、添加、存储)的简单组合，如果多个线程凑巧试图同时对 <code>volatile</code> 计数器执行增量操作，那么它的更新值有可能会丢失。</p><p>如果读操作远远超过写操作，可以结合使用内部锁和 <code>volatile</code> 变量来减少公共代码路径的开销。</p><p>安全的计数器<strong>使用 <code>synchronized</code> 确保增量操作是原子的</strong>，并<strong>使用 <code>volatile</code> 保证当前结果的可见性</strong>。</p><p>如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 <code>volatile</code> 读操作，<strong>这通常要优于一个无竞争的锁获取的开销。</strong></p><p>（总的来说就是读交给<code>volatile</code>，写交给<code>synchronized</code>）</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@ThreadSafe</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CheesyCounter</span> <span class="token punctuation">{</span>
    <span class="token comment">// Employs the cheap read-write lock trick</span>
    <span class="token comment">// All mutative operations MUST be done with the &#39;this&#39; lock held</span>
    <span class="token annotation punctuation">@GuardedBy</span><span class="token punctuation">(</span><span class="token string">&quot;this&quot;</span><span class="token punctuation">)</span> <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>
 
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>
 
    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li><li><blockquote><p>六. 双重检查</p></blockquote><p>单例模式的一种实现方式，但很多人会忽略 <code>volatile</code> 关键字，因为没有该关键字，程序也可以很好的运行，只不过代码的稳定性总不是 100%，说不定在未来的某个时刻，隐藏的 bug 就出来了。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div></li></ul><h1 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h1><p>本章我们详细的介绍了<code>volatile</code>关键字，这么一个开销小于<code>synchronized</code>却能为我们提供并发安全的可见性和有序性的关键字。</p><p>相信学习了本篇文章后能对<code>happens-before</code>原则有着更深的理解，并且能够使用<code>volatile</code>关键字来保证<code>happens-before</code>原则，写出并发安全的程序。</p><p>本章参考：</p><ul><li>https://zhuanlan.zhihu.com/p/126275344</li><li>https://www.cnblogs.com/dolphin0520/p/3920373.html</li><li>https://pdai.tech/md/java/thread/java-thread-x-key-volatile.html</li></ul><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></footer><!----><!--[--><!--]--><!----></main><ul class="catalog" style="top:0px;"><li class="level-2 toc-link-jmm的设计">JMM的设计</li><li class="level-2 toc-link-happens-before原则">happens-before原则</li><li class="level-2 toc-link-volatile可见性实现原理">volatile可见性实现原理</li><li class="level-2 toc-link-volatile有序性实现原理">volatile有序性实现原理</li></ul></div><!--]--></div><div class="search-page" role="search"><span class="search-close"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" width="28" height="28" fill="currentColor"><path d="M224 416c-8.188 0-16.38-3.125-22.62-9.375l-192-192c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L224 338.8l169.4-169.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-192 192C240.4 412.9 232.2 416 224 416z"></path></svg></span><div class="gungnir-search-box"><input placeholder="$ grep ..." autocomplete="off" spellcheck="false" value><!----></div></div><div class="menu-btn-container"><div class="menu-btn-wrapper"><div class="menu-btn"><div style="" class="menu-btn-icon"><span></span><span></span><span></span></div><div style="display:none;" class="menu-text">0</div><svg class="menu-progress"><circle class="menu-border" cx="50%" cy="50%" r="48%" style="stroke-dasharray:0% 314.15926%;"></circle></svg></div><div class="menu-btn-child-wrapper"><div class="toggle-dark-button menu-btn-child" title="toggle dark mode"><svg class="ov-icon" style="font-size:1.2em;display:none;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"/></svg><svg class="ov-icon" style="font-size:1.2em;display:none;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 00283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"/></svg><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M224 96l16-32 32-16-32-16-16-32-16 32-32 16 32 16 16 32zM80 160l26.66-53.33L160 80l-53.34-26.67L80 0 53.34 53.33 0 80l53.34 26.67L80 160zm352 128l-26.66 53.33L352 368l53.34 26.67L432 448l26.66-53.33L512 368l-53.34-26.67L432 288zm70.62-193.77L417.77 9.38C411.53 3.12 403.34 0 395.15 0c-8.19 0-16.38 3.12-22.63 9.38L9.38 372.52c-12.5 12.5-12.5 32.76 0 45.25l84.85 84.85c6.25 6.25 14.44 9.37 22.62 9.37 8.19 0 16.38-3.12 22.63-9.37l363.14-363.15c12.5-12.48 12.5-32.75 0-45.24zM359.45 203.46l-50.91-50.91 86.6-86.6 50.91 50.91-86.6 86.6z"/></svg></div><div class="menu-btn-child"><svg class="ov-icon" style="font-size:1.7999999999999998em;" aria-hidden="true" width="28.799999999999997" height="28.799999999999997" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"/></svg></div><div class="menu-btn-child"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M240.971 130.524l194.343 194.343c9.373 9.373 9.373 24.569 0 33.941l-22.667 22.667c-9.357 9.357-24.522 9.375-33.901.04L224 227.495 69.255 381.516c-9.379 9.335-24.544 9.317-33.901-.04l-22.667-22.667c-9.373-9.373-9.373-24.569 0-33.941L207.03 130.525c9.372-9.373 24.568-9.373 33.941-.001z"/></svg></div><div class="menu-btn-child menu-toc-btn"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M48 48a48 48 0 1048 48 48 48 0 00-48-48zm0 160a48 48 0 1048 48 48 48 0 00-48-48zm0 160a48 48 0 1048 48 48 48 0 00-48-48zm448 16H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16v-32a16 16 0 00-16-16zm0-320H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16V80a16 16 0 00-16-16zm0 160H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16v-32a16 16 0 00-16-16z"/></svg></div><div class="toggle-sidebar-button menu-btn-child menu-btn-sidebar" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-1.6 -1.6 19.2 19.2" fill="currentColor"><path d="M14 2a1 1 0 011 1v10a1 1 0 01-1 1H2a1 1 0 01-1-1V3a1 1 0 011-1h12zM2 1a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V3a2 2 0 00-2-2H2z"/><path d="M3 4a1 1 0 011-1h2a1 1 0 011 1v8a1 1 0 01-1 1H4a1 1 0 01-1-1V4z"/></svg></div></div></div></div><footer class="footer"><span>
                &copy; pixel-revolve 2021-2022
                <br>
                Powered by <a href="https://vuepress.vuejs.org" target="_blank">VuePress</a> &
                <a href="https://github.com/Renovamen/vuepress-theme-gungnir" target="_blank">Gungnir</a>
                </span></footer></div><!--]--></div>
    <script type="module" src="/assets/app.9fd9aa02.js" defer></script>
  </body>
</html>
