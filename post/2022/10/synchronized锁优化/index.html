<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.38">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/img/logo-broccoli.png"><title>绕不开的并发编程--synchronized锁优化 | pixel-revolve</title><meta name="description" content="爱编程，爱生活">
    <link rel="modulepreload" href="/assets/app.9fd9aa02.js"><link rel="modulepreload" href="/assets/index.html.6a7a1e39.js"><link rel="modulepreload" href="/assets/index.html.6c730479.js">
    <link rel="stylesheet" href="/assets/style.2781e754.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container no-sidebar"><!--[--><header class="navbar invert"><span><a href="/" class=""><span class="site-name">$ cd /home/</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="Home"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/></svg></span><span>Home</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/tags/" class="" aria-label="Tags"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M17.707 9.293a1 1 0 010 1.414l-7 7a1 1 0 01-1.414 0l-7-7A.997.997 0 012 10V5a3 3 0 013-3h5c.256 0 .512.098.707.293l7 7zM5 6a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/></svg></span><span>Tags</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/links/" class="" aria-label="Links"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z" clip-rule="evenodd"/></svg></span><span>Links</span><!--[--><!--]--></a></div><!--]--><div class="navbar-item"><a style="cursor:pointer;"><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 2c4.968 0 9 4.032 9 9s-4.032 9-9 9-9-4.032-9-9 4.032-9 9-9zm0 16c3.867 0 7-3.133 7-7 0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7zm8.485.071l2.829 2.828-1.415 1.415-2.828-2.829 1.414-1.414z"/></svg></span><span>Search</span></a></div></nav><!--[--><!--]--><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="Home"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/></svg></span><span>Home</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/tags/" class="" aria-label="Tags"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M17.707 9.293a1 1 0 010 1.414l-7 7a1 1 0 01-1.414 0l-7-7A.997.997 0 012 10V5a3 3 0 013-3h5c.256 0 .512.098.707.293l7 7zM5 6a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/></svg></span><span>Tags</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/links/" class="" aria-label="Links"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z" clip-rule="evenodd"/></svg></span><span>Links</span><!--[--><!--]--></a></div><!--]--><div class="navbar-item"><a style="cursor:pointer;"><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 2c4.968 0 9 4.032 9 9s-4.032 9-9 9-9-4.032-9-9 4.032-9 9-9zm0 16c3.867 0 7-3.133 7-7 0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7zm8.485.071l2.829 2.828-1.415 1.415-2.828-2.829 1.414-1.414z"/></svg></span><span>Search</span></a></div></nav><!--[--><!--]--><!----><!--[--><!--]--></aside><!--]--><div class="page-content"><!--[--><div class="show-catalog post-wrapper"><div class="article-header use-image post-header" style="background-image:url(/img/blog_cover/2022/10/绕不开的并发编程--synchronized锁优化.jpg);"><div class="article-header-mask" style="background:rgba(40, 57, 101, .4);"></div><div class="article-header-content"><div class="article-tags"><!--[--><span class="article-tag">并发编程</span><!--]--></div><h1 class="article-title">绕不开的并发编程--synchronized锁优化</h1><p class="article-subtitle">自旋锁，偏向锁，轻量级锁...</p><div class="article-icons"><div class="article-icon"><svg class="ov-icon" style="font-size:1.08em;" aria-hidden="true" width="17.28" height="17.28" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M313.6 304c-28.7 0-42.5 16-89.6 16-47.1 0-60.8-16-89.6-16C60.2 304 0 364.2 0 438.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-25.6c0-74.2-60.2-134.4-134.4-134.4zM400 464H48v-25.6c0-47.6 38.8-86.4 86.4-86.4 14.6 0 38.3 16 89.6 16 51.7 0 74.9-16 89.6-16 47.6 0 86.4 38.8 86.4 86.4V464zM224 288c79.5 0 144-64.5 144-144S303.5 0 224 0 80 64.5 80 144s64.5 144 144 144zm0-240c52.9 0 96 43.1 96 96s-43.1 96-96 96-96-43.1-96-96 43.1-96 96-96z"/></svg><span>pixel-revolve</span></div><div class="article-icon"><svg class="ov-icon" style="font-size:1.08em;" aria-hidden="true" width="17.28" height="17.28" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M400 64h-48V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H160V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zm-6 400H54c-3.3 0-6-2.7-6-6V160h352v298c0 3.3-2.7 6-6 6z"/></svg><span>2022-10-29</span></div><div class="article-icon"><svg class="ov-icon" style="font-size:1.08em;" aria-hidden="true" width="17.28" height="17.28" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M17.618 5.968l1.453-1.453 1.414 1.414-1.453 1.453a9 9 0 11-1.414-1.414zM12 20a7 7 0 100-14 7 7 0 000 14zM11 8h2v6h-2V8zM8 1h8v2H8V1z"/></svg><span>32 min</span></div></div></div><!----></div><main class="page post-content"><!--[--><!--]--><div class="theme-gungnir-content"><!--[--><h1 id="简单介绍" tabindex="-1"><a class="header-anchor" href="#简单介绍" aria-hidden="true">#</a> 简单介绍</h1><blockquote><p>本篇我们将介绍并发编程中会遇见的各种锁包括但不限于：「自旋锁」，「偏向锁」，「轻量级锁」...</p><p>接着我们将由浅入深的进入到对锁的学习和探索当中。</p></blockquote><h2 id="java对象头" tabindex="-1"><a class="header-anchor" href="#java对象头" aria-hidden="true">#</a> Java对象头</h2><blockquote><p><code>new</code>关键字可以创建一个类的实例对象，对象存于内存的堆中，并给其分配一个内存地址，那么是否想过如下问题？</p></blockquote><ul><li><strong>实例对象是以怎样的形态存在内存中的?</strong></li><li><strong>一个Object对象在内存中占用多大?</strong></li><li><strong>对象中的属性是如何在内存中分配的?</strong></li></ul><p>接下来我们就来解决这几个问题。首先先是学习Java对象在内存中的存储形式开始。</p><blockquote><p>对象内存布局</p></blockquote><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/104b6df0aa4f42919522a10394ed4c64~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p><code>HotSpot</code>虚拟机中，<strong>对象在内存中存储的布局</strong>可以分为三块区域：对象头（<code>Header</code>）、实例数据（<code>Instance Data</code>）和对齐填充（<code>Padding</code>）。它们分别存储以下信息：</p><ul><li><p><strong>对象头（object header）</strong></p><p>包括了关于堆对象的布局、类型、<code>GC</code>状态、同步状态和标识哈希码的基本信息。Java对象和vm内部对象都有一个共同的对象头格式。</p><ul><li><p><strong><code>Mark Word</code>(标记字段)</strong></p><p>对象的<code>Mark Word</code>部分在32位<code>JVM</code>占<code>4</code>个字节，在64位<code>JVM</code>占<code>8</code>个字节，其内容是一系列的标记位，比如轻量级锁的标记位，偏向锁标记位等等。</p><blockquote><p><code>Mark Word</code>存储数据细节</p></blockquote><p><code>Mark Word</code>在不同的锁状态下存储的内容不同，在32位<code>JVM</code>中是这么存的：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62ce981c41734ac0b7858e54bafce864~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>在64位<code>JVM</code>中是这么存的：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56f48e272cfd4552b4272c5965f0678b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>虽然它们在不同位数的<code>JVM</code>中长度不一样，但是基本组成内容是一致的。</p><ul><li><p><strong>锁标志位（lock）</strong></p><p>区分锁状态，11时表示对象待<code>GC</code>回收状态, 只有最后2位锁标识(11)有效。</p></li><li><p><strong>biased_lock</strong></p><p>是否偏向锁，由于无锁和偏向锁的锁标识都是 01，没办法区分，这里引入一位的偏向锁标识位。</p></li><li><p><strong>分代年龄（age）</strong></p><p>表示对象被<code>GC</code>的次数，当该次数到达阈值的时候，对象就会转移到老年代。</p></li><li><p><strong>对象的hashcode（hash）</strong></p><p>运行期间调用<code>System.identityHashCode()</code>来计算，延迟计算，并把结果赋值到这里。当对象加锁后，计算的结果31位不够表示，在偏向锁，轻量锁，重量锁，<code>hashcode</code>会被转移到<code>Monitor</code>中。</p></li><li><p><strong>偏向锁的线程ID（JavaThread）</strong></p><p>偏向模式的时候，当某个线程持有对象的时候，对象这里就会被置为该线程的ID。 在后面的操作中，就无需再进行尝试获取锁的动作。</p></li><li><p><strong>epoch</strong></p><p>偏向锁在<code>CAS</code>锁操作过程中，偏向性标识，表示对象更偏向哪个锁。</p></li><li><p><strong>ptr_to_lock_record</strong></p><p>轻量级锁状态下，指向栈中锁记录的指针。当锁获取是无竞争的时，<code>JVM</code>使用原子操作而不是<code>OS</code>互斥。这种技术称为轻量级锁定。在轻量级锁定的情况下，<code>JVM</code>通过<code>CAS</code>操作在对象的标题字中设置指向锁记录的指针。</p></li><li><p><strong>ptr_to_heavyweight_monitor</strong></p><p>重量级锁状态下，指向对象监视器<code>Monitor</code>的指针。如果两个不同的线程同时在同一个对象上竞争，则必须将轻量级锁定升级到<code>Monitor</code>以管理等待的线程。在重量级锁定的情况下，<code>JVM</code>在对象的<code>ptr_to_heavyweight_monitor</code>设置指向<code>Monitor</code>的指针。</p></li></ul></li><li><p><strong><code>Klass Pointer</code>（<code>Class</code>对象指针）</strong></p><p><code>Class</code>对象指针的大小也是4个字节，其指向的位置是对象对应的<code>Class</code>对象（其对应的元数据对象）的内存地址。</p><p><code>JVM</code>通过这个指针来确定这个对象是哪个类的实例。</p></li><li><p><code>Array Length</code></p><p>只有对象是数组才会有这部分</p></li></ul></li><li><p><strong>实例数据（Instance Data）</strong></p><p>主要是存放类的数据信息，父类的信息，对象字段属性信息。</p><ul><li><p><strong>对象实际数据</strong></p><p>这里面包括了对象的所有成员变量，其大小由各个成员变量的大小决定，比如：<code>byte</code>和<code>boolean</code>是1个字节，<code>short</code>和<code>char</code>是2个字节，<code>int</code>和<code>float</code>是4个字节，<code>long</code>和<code>double</code>是8个字节，<code>reference</code>是4个字节</p></li></ul></li><li><p><strong>对齐填充（Padding）</strong></p><p>为了字节对齐，填充的数据，不是必须的。</p><ul><li><p><strong>对齐</strong></p><p>最后一部分是对齐填充的字节，按<code>8</code>个字节填充。</p><blockquote><p>为什么要对齐数据？</p></blockquote><p><strong>让字段只出现在同一CPU的缓存行中</strong></p><p>如果字段不是对齐的，那么就有可能出现<strong>跨缓存行的字段</strong>。</p><p>也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。其实<strong>对其填充的最终目的是为了计算机高效寻址。</strong></p></li></ul></li></ul><blockquote><p>从虚拟机信息中看对象在内存中的构成</p></blockquote><p>我们使用<code>openjdk</code>提供的工具包来获取对象的信息和虚拟机信息。</p><div class="language-xml ext-xml line-numbers-mode"><pre class="language-xml"><code> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.openjdk.jol<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jol-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>0.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>我们通过一个简单的<code>Hello</code>类的实例对象来打印对象内部信息：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token punctuation">{</span>
     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token class-name">Hello</span> hello<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>打印结果为：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/246486ba18744d05b9c7e075b4da6360~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>可以看到，<code>hello</code>对象实例共占据16字节，对象头（object header）占据12字节，其中 <code>mark word</code>占8字节，<code>klass point</code> 占4字节，另外剩余4字节是填充对齐的。</p><ul><li><blockquote><p>指针压缩</p></blockquote><p>由于默认开启了指针压缩，所以对象头占了12字节，我们可以通过配置vm参数关闭指针压缩<code>-XX:-UseCompressedOops</code></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/942cbedd8fa24a65ac1f2a12ee3c22e5~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>如果关闭指针压缩重新打印对象的内存布局，可以发现总SIZE变大了</p><p>对象头所占用的内存大小变为16字节，其中 <code>mark word</code>占8字节，<code>klass point</code> 占8字节，无对齐填充。</p><ul><li><blockquote><p>开启指针压缩有什么用？</p></blockquote><p><strong>开启指针压缩可以减少对象的内存使用。</strong></p><p>从两次打印的<code>hello</code>对象布局信息来看，关闭指针压缩时，对象头的SIZE增加了4字节，这里由于<code>hello</code>对象是无属性的</p><p>可以试试增加几个属性字段来看下，这样会明显的发现SIZE增长。因此开启指针压缩，理论上来讲，大约能节省百分之五十的内存。JDK1.8及以后版本已经默认开启指针压缩，无需配置。</p></li></ul></li></ul><ul><li><blockquote><p>数组对象</p></blockquote><p>我们再看下数组对象的内存布局，看下和普通对象的有什么异同（这里我们开启了指针压缩）</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token punctuation">{</span>
     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hello<span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLayout</span><span class="token punctuation">.</span><span class="token function">parseInstance</span><span class="token punctuation">(</span>hello<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPrintable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>打印结果如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/750729303d0048d5b2fb87a81fb7f9ad~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>可以看到这时总SIZE为共24字节，对象头占16字节，其中<code>Mark Work</code>占8字节，<code>Klass Point</code> 占4字节，<code>array length</code> 占4字节。因为里面只有一个 int 类型的1，所以数组对象的实例数据占据4字节，剩余对齐填充占据4字节。</p></li></ul><blockquote><p>对象年龄最大15岁的原因</p></blockquote><p>对象在<code>Suvivor</code>中每熬过一次<code>MinorGC</code>，年龄就增加1，当它的年龄增加到15岁就会被晋升到老年代中。</p><p>在<code>Mark Word</code>中可以发现标记对象分代年龄的分配的空间是4bit，而4bit能表示的最大数就是2^4-1 = 15。</p><blockquote><p>什么是Java对象头？</p></blockquote><p>根据上面对象内存模型的介绍我们已经很清楚了，「Java对象头」就是对象在内存中的存储的一块分区，其中对象头包括两个部分<code>Mark Word</code> 和 <code>Class</code>对象指针，如果是数组对象的话还有<code>Array Length</code>。</p><h2 id="锁的类型" tabindex="-1"><a class="header-anchor" href="#锁的类型" aria-hidden="true">#</a> 锁的类型</h2><blockquote><p>上面我们分析了Java对象头，从对象头的<code>Mark Word</code>中发现了还有锁标志位用于标志不同的锁。所以可以知道对象锁实际上是有不同状态的。</p></blockquote><blockquote><p>对象锁实际是有不同状态的？</p></blockquote><p>Java对象的锁状态一共有4种，级别从低到高依次为：<strong>无锁(01) -&gt; 偏向锁(01) -&gt; 轻量级锁(00) -&gt; 重量级锁(10)。</strong></p><p>锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。</p><p>这些<strong>不同的对象锁的实现</strong>都是JDK1.6对<code>synchronized</code>底层做的优化。而1.6之前都是基于<code>monitor</code>机制的重量级锁。</p><p><code>JDK 1.6</code>中默认是开启偏向锁和轻量级锁的，我们也可以通过<code>-XX:-UseBiasedLocking</code>来禁用偏向锁。</p><p>要注意锁的升级目的是为了<strong>提高锁的获取效率和释放效率</strong>。</p><blockquote><p>这里我找了「美团技术团队」根据特性将锁进行分组分类，可以说是总结的而非常全面到位了</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4dec250cb1ba4ce6a45e71e9983c7950~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>本篇将会介绍上面这张图里面的大部分锁。</p><p>而一些非锁实现而是锁思想的锁将会在分析它的实现的时候介绍。</p><h2 id="为什么需要锁优化" tabindex="-1"><a class="header-anchor" href="#为什么需要锁优化" aria-hidden="true">#</a> 为什么需要锁优化？</h2><blockquote><p>为什么JDK1.6要引入锁优化？</p></blockquote><p>因为监视器锁（<code>monitor</code>）实现的同步时互斥同步，互斥导致的Java线程的阻塞以及唤醒，都是依靠操作系统来实现的。</p><p>详细来说<code>JVM</code>中<code>monitorenter</code>和<code>monitorexit</code>字节码就是依赖于底层的操作系统的<code>Mutex Lock</code>来实现的。</p><p>使用<code>Mutex Lock</code><strong>需要将当前线程挂起并从用户态切换到内核态来执行</strong>，这种<strong>切换的代价是非常昂贵</strong>的；</p><p>然而在现实中的大部分情况下，同步方法是运行在单线程环境（无锁竞争环境）<strong>如果每次都调用<code>Mutex Lock</code>那么将严重的影响程序的性能。</strong></p><blockquote><p>接下来我们就来分析<code>synchronized</code>的锁优化。</p></blockquote><h1 id="synchronized的锁优化" tabindex="-1"><a class="header-anchor" href="#synchronized的锁优化" aria-hidden="true">#</a> synchronized的锁优化</h1><blockquote><p>JDK1.6引入了什么锁优化技术？</p></blockquote><p>JDK1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销。</p><p>这里我们简单的列举一下这几种技术：</p><ul><li><p><code>锁粗化(Lock Coarsening)</code></p><p>也就是减少不必要的紧连在一起的<code>unlock</code>，<code>lock</code>操作，将多个连续的锁扩展成一个范围更大的锁。</p></li><li><p><code>锁消除(Lock Elimination)</code></p><p>通过运行时<code>JIT</code>编译器的逃逸分析来<strong>消除一些没有在当前同步块以外被其他线程共享的数据的锁保护</strong></p><p>通过逃逸分析也可以在线程本的Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。</p></li><li><p><code>轻量级锁(Lightweight Locking)</code></p><p>「轻量级锁」这种实现基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码<strong>一般都处于无锁竞争状态</strong>(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在<code>monitorenter</code>和<code>monitorexit</code>中只需要依靠一条<code>CAS</code>原子指令就可以完成锁的获取及释放。</p><p>当存在锁竞争的情况下，执行<code>CAS</code>指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒(具体处理步骤下面详细讨论)。</p></li><li><p><code>偏向锁(Biased Locking)</code></p><p>是<strong>为了在无锁竞争的情况下避免在锁获取过程中执行不必要的<code>CAS</code>原子指令</strong>，因为<code>CAS</code>原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。</p></li><li><p><code>适应性自旋(Adaptive Spinning)</code></p><p>当线程在获取轻量级锁的过程中执行<code>CAS</code>操作失败时，在进入与<code>monitor</code>相关联的操作系统重量级锁(<code>mutex semaphore</code>)前会进入忙等待(<code>Spinning</code>)然后再次尝试</p><p>当尝试一定的次数后如果仍然没有成功则调用与该<code>monitor</code>关联的<code>semaphore</code>(即互斥锁)进入到阻塞状态。</p></li></ul><blockquote><p>接下来我们来详细的解释各种锁</p></blockquote><h2 id="自旋锁" tabindex="-1"><a class="header-anchor" href="#自旋锁" aria-hidden="true">#</a> 自旋锁</h2><blockquote><p>什么是自旋锁？</p></blockquote><p>我们知道只有获取了锁的线程才能访问临界区资源，并且同一时刻只有一个线程可以获取到锁。那么没有获取到锁的线程该怎么办？</p><p>一般有两种方式：</p><ul><li>线程自己阻塞（BLOCK），等待重新调度请求，这个就是「互斥锁」。</li></ul><ul><li>没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，线程不需要阻塞（BLOCK），这个就是「自旋锁」。</li></ul><p>如果用一句话来概括互斥锁和自旋锁：<strong>互斥锁是睡等，自旋锁是忙等。</strong></p><p>早在JDK1.4.2就引入了自旋锁对<code>synchronized</code>关键字进行了优化，我们可以用<code>-XX:+UseSpinning</code>来开启自旋锁。在JDK1.6中则是将自旋锁设置为默认开启。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a3420ed113440f8a0f927b4bcf89361~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>于是这种采用循环加锁-&gt;等待的机制被称为「自旋锁」(<code>spinlock</code>)</p><blockquote><p>为什么需要自旋锁？</p></blockquote><p>在没有加入锁优化时，<code>synchronized</code>是一个非常“胖大”的家伙。这一点可以在「为什么需要锁优化？」已经解释。</p><p>同时<code>HotSpot</code>团队注意到在很多情况下，<strong>共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和回复阻塞线程并不值得。</strong></p><p>在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会(自旋)，但不放弃CPU的执行时间。等待持有锁的线程有可能很快就会释放锁。</p><p>如果线程请求获取监视器锁失败，并不立刻阻塞线程，而是让线程执行一个忙循环（自旋）。如果持有锁的线程能在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态了，这样就<strong>避免了用户进程和内核切换的消耗。</strong></p><p>自旋的消耗会小于上面所说的这种线程阻塞挂起再唤醒的消耗，后者的操作会导致线程发生两次上下文切换。</p><blockquote><p>自旋实现的原理</p></blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1275cb629e3842b882da76ecbc473f5f~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>自旋之后再次尝试获取锁。如果获取锁失败，这个过程会循环一定次数，超过某个阀值，如果还是获取不到锁，才阻塞线程。</p><p>自旋可以通过**<code>-XX:+UserSpinning</code><strong>参数来开启，自旋的次数通过</strong><code>-XX:PreBlockSpin</code>**来更改（默认是10）。</p><p>自旋锁的实现原理使<code>CAS</code>，<code>AtomicInteger</code>中调用<code>unsafe</code>进行自增操作的源码中的<code>do-while</code>循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2be855e6f7294ada806ef5f8b7e7d277~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><blockquote><p>自旋锁的实现</p></blockquote><p>我们用Java代码来实现一个简单的自旋锁：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpinLock</span> <span class="token punctuation">{</span>
 ​
     <span class="token keyword">private</span> <span class="token class-name">AtomicBoolean</span> available <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicBoolean</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 ​
     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
 ​
         <span class="token comment">// 循环检测尝试获取锁</span>
         <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
             <span class="token comment">// doSomething...</span>
         <span class="token punctuation">}</span>
 ​
     <span class="token punctuation">}</span>
 ​
     <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token comment">// 尝试获取锁，成功返回true，失败返回false</span>
         <span class="token keyword">return</span> available<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 ​
     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>available<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;释放锁失败&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
 ​
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>这种简单的自旋锁有一个问题：无法保证多线程竞争的公平性。</p><p>对于上面的<code>SpinLock</code>，当多个线程想要获取锁时，谁先将<code>available</code>设置为<code>false</code>谁就能最先获得锁，这可能会造成某些线程一直都未获取到锁造成「线程饥饿」。</p><p>一般我们会用排队的方式解决这样的问题，我们把这种锁叫做「排队自旋锁」（<code>QueuedSpinlock</code>）。</p><p>计算机科学家们使用了各种方式来实现排队自旋锁，如<code>TicketLock</code>，<code>MCSLock</code>，<code>CLHLock</code>...（但这些不是本章的重点，有兴趣的同学可以自行检索）</p><blockquote><p>自旋锁的问题</p></blockquote><p>自旋虽然避免了线程切换的损耗，但是<strong>需要占用处理器时间</strong>。</p><p>自旋的效果取决于锁被占用的时间，<strong>如果锁被占用的时间很短，自旋等待的效果就会很好。</strong></p><p>但是如果<strong>持有锁的线程需要长时间占用锁执行同步块</strong>，这个时候就不适合使用自旋锁了。这种情况下自旋只会白白消耗处理器资源，带来性能上的损耗。</p><p>如果<strong>锁竞争激烈</strong>，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗。这种情况下我们需要关闭自旋锁。</p><blockquote><p>JDK1.6不仅将自旋锁变成默认开启，而且在JDK1.6还引入了自适应自旋锁用于解决上面的问题。</p></blockquote><h3 id="自适应自旋锁" tabindex="-1"><a class="header-anchor" href="#自适应自旋锁" aria-hidden="true">#</a> 自适应自旋锁</h3><blockquote><p>自适应意味着什么？</p></blockquote><p>自适应意味着自旋的时间不再固定了，而是<strong>由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</strong></p><ul><li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它允许自旋等待等待持续相对更长的时间。</li></ul><ul><li>如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</li></ul><blockquote><p>自适应自旋有什么用？</p></blockquote><p><strong>自适应自旋解决的是「锁竞争时间不确定」的问题</strong>。</p><p><code>JVM</code>很难感知到确切的锁竞争时间，而交给用户分析就违反了<code>JVM</code>的设计初衷。</p><p>自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定。因此，可以根据上一次自旋的时间与结果调整下一次自旋的时间。</p><h2 id="偏向锁" tabindex="-1"><a class="header-anchor" href="#偏向锁" aria-hidden="true">#</a> 偏向锁</h2><blockquote><p>为什么会有偏向锁？</p></blockquote><p><strong>大多数情况下</strong>，锁不仅不存在多线程竞争，而且总是由<strong>同一个线程多次获得</strong>，同一个线程反复获取锁，即便是按照轻量级锁的方式获取锁（<code>CAS</code>），也是有一定代价的，如何让这个代价更小一点呢？</p><p>这个时候我们就搬出来偏向锁来解决这个问题了。</p><blockquote><p>什么是偏向锁？</p></blockquote><p>偏向锁对象对应的<code>Mark Word</code>信息：</p><table><thead><tr><th>bit fields</th><th></th><th>是否偏向锁</th><th>锁标志位</th></tr></thead><tbody><tr><td>threadId</td><td>epoch</td><td>1</td><td>01</td></tr></tbody></table><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p>「偏向」的实际含义是，偏向锁「假定」将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁）</p><p>因此，只需要再锁对象的<code>Mark Word</code>中<code>CAS</code>记录<code>owner</code>（该线程的ID），如果记录成功，则偏向锁获取成功，记录对象的锁状态为偏向锁（最后3位设置为<code>101</code>），以后当线程等于<code>owner</code>就可以零成本的直接获取锁。</p><ul><li><blockquote><p>什么是epoch？</p></blockquote><p>可以理解成是第几代偏向锁。</p><ul><li><blockquote><p>epoch有什么用？</p></blockquote><ul><li><p>如果有线程请求偏向锁，需要判断<code>Mark Word</code>最后三位是否为<code>101</code>，是否指向的是当前线程的地址，并且判断<code>epoch</code>值和锁对象的类中的<code>epoch</code>值是否相同。如果都满足，那么说明当前线程持有该偏向锁，就可以直接返回。</p></li><li><p>偏向锁在有竞争的时候是要执行撤销操作的，其实就是要升级成轻量级锁。</p><p>而当一类对象撤销的次数过多，比如有个 Hello 类的对象作为偏向锁，经常被撤销，次数到了一定阈值(<code>XX:BiasedLockingBulkRebiasThreshold</code>，默认为 20 )就会把当代的偏向锁废弃，把类的 <code>epoch</code> 加一。</p><p>所以<strong>当类对象和锁对象的 <code>epoch</code> 值不等的时候，当前线程可以将该锁重偏向至自己</strong>，因为前一代偏向锁已经废弃了。</p></li></ul></li></ul></li></ul><blockquote><p>偏向锁适应的并发场景</p></blockquote><p>偏向锁适应无实际锁竞争，且将来只有第一个申请锁的线程会使用锁的场景。</p><blockquote><p>偏向锁的升级（锁膨胀）</p></blockquote><p>在多线程环境下，不可能只是同一个线程一直获取这个锁，如果<strong>出现了多个线程竞争的情况</strong>，也就有了偏向锁升级成轻量级锁的过程。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98e6085ea2de47de9f67e29e59f3bcc6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>偏向锁无法使用自旋锁优化，一旦有其他线程申请锁，就破坏了偏向锁的「假定」。那么偏向锁将很快膨胀为轻量级锁。</p><blockquote><p>偏向锁是有缺点的，它比较容易失效膨胀，一旦失效后就需要进行「锁撤销」的操作，接着我们就来讲讲锁撤销。</p></blockquote><h3 id="锁撤销" tabindex="-1"><a class="header-anchor" href="#锁撤销" aria-hidden="true">#</a> 锁撤销</h3><blockquote><p>什么是锁撤销？</p></blockquote><p>承接上面的偏向锁膨胀升级成轻量级锁的场景。</p><p>由于偏向锁失效了，那么接下来就得把该锁撤销，锁撤销的开销花费还是挺大的，大概过程如下：</p><ul><li>在一个安全点停止拥有锁的线程</li><li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和<code>MarkWord</code>，使其成为无锁状态</li><li>唤醒当前线程，将当前锁升级成轻量级锁（这一点将在「轻量级锁」中详细介绍）</li></ul><blockquote><p>所以，如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭</p></blockquote><p>可以使用参数<code>-XX:-UseBiasedLocking</code>禁止偏向锁优化（默认打开）</p><h2 id="轻量级锁" tabindex="-1"><a class="header-anchor" href="#轻量级锁" aria-hidden="true">#</a> 轻量级锁</h2><blockquote><p>什么是轻量级锁？</p></blockquote><p>轻量级锁对象对应的<code>Mark Word</code>信息：</p><table><thead><tr><th>bit fields</th><th>锁标志位</th></tr></thead><tbody><tr><td>指向栈中锁记录的指针（ptr_to_lock_record）</td><td>00</td></tr></tbody></table><p>在JDK 1.6之后引入了轻量级锁，需要注意的是轻量级锁并不是替代重量级锁的，而是<strong>对在大多数情况下同步块并不会有竞争出现提出的一种优化。</strong></p><p>轻量级锁的目标就是减少<strong>无实际竞争情况下</strong>，使用重量级锁产生的性能消耗。</p><p>轻量级锁是相对于重量级锁而言的。使用轻量级锁时，不需要申请互斥量（<code>mutex</code>），仅仅将<code>Mark Word</code>中部分字节<code>CAS</code>更新指向线程栈中的<code>Lock Record</code>，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。</p><blockquote><p>轻量级锁适应的并发场景</p></blockquote><p>轻量级锁适应无实际锁竞争，多个线程交替使用锁；允许短时间的锁竞争。</p><blockquote><p>轻量级锁的升级</p></blockquote><p>轻量级锁天然是瞄准不存在锁竞争的场景，如果存在锁竞争但不激烈，仍然可以用自旋锁优化，<strong>自旋失败后再膨胀成重量级锁</strong>。</p><h3 id="轻量级锁加锁" tabindex="-1"><a class="header-anchor" href="#轻量级锁加锁" aria-hidden="true">#</a> 轻量级锁加锁</h3><blockquote><p>轻量级加锁过程</p></blockquote><p>这个过程也可以叫做偏向锁撤销后升级成轻量级锁</p><ul><li><p>线程在自己的栈帧中创建锁记录<code>LockRecord</code></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51a14ce877ea423c8913c19f4ecf95d4~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><ul><li><blockquote><p>什么是锁记录？</p></blockquote><p>在线程执行同步块之前，<code>JVM</code>会先在当前线程的栈帧中创建一个名为锁记录(<code>Lock Record</code>)的空间。</p><p><code>Lock Record</code>中包含一个<code>_displaced_header</code>属性，用于存储锁对象目前的<code>Mark Word</code>的拷贝(<code>JVM</code>会将对象头中的<code>Mark Word</code>拷贝到锁记录中)</p></li></ul></li><li><p>将锁对象的对象头中的<code>MarkWord</code>赋值到线程的刚刚创建的锁记录中</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8ce9314bc04463b93609e2e920acee3~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>这个复制过来的记录叫做 <code>Displaced Mark Word</code>。具体来讲，是将 <code>mark word</code> 放到锁记录的 <code>_displaced_header</code> 属性中。</p><p>（上图所示的对象没有被锁定，锁标志位为01状态。）</p></li><li><p>将锁记录中的<code>Owner</code>指针指向锁对象</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba3ee92b82e540eba6765aec76b47ec6~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p></li><li><p>虚拟机使用<code>CAS</code>操作将锁对象的对象头的<code>MarkWord</code>更新为指向锁记录的指针，并且更新锁标志位为00</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1304ecae9e844d52b0113c4929d5f9b3~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>虚拟机使用<code>CAS</code>操作将锁对象对象头的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。</p><ul><li>如果更新成功了，那么这个线程就有用了该对象的锁，并且对象<code>Mark Word</code>的锁标志位更新为<code>00</code>，即表示<strong>此对象处于轻量级锁定状态。</strong></li></ul><ul><li><p>如果这个更新操作失败，<code>JVM</code>会检查当前的<code>Mark Word</code>中是否存在指向当前线程的栈帧的指针</p><p>如果有，说明该锁已经被获取，可以直接调用。</p><p>如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀为重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为<code>10</code>。<code>Mark Word</code>中存储的时指向重量级锁的指针。</p></li></ul><p>注意到这里栈帧中的锁记录存储的锁对象加轻量锁之前的状态，</p></li></ul><h3 id="轻量级锁解锁" tabindex="-1"><a class="header-anchor" href="#轻量级锁解锁" aria-hidden="true">#</a> 轻量级锁解锁</h3><blockquote><p>轻量级锁解锁过程</p></blockquote><p>解锁的思路是使用 <code>CAS</code> 操作把当前线程的栈帧中的 <code>Displaced Mark Word</code> 替换回锁对象中去，如果替换成功，则解锁成功。</p><p>如果失败，表示有其他线程尝试过获取该锁，则要在释放锁的同时唤醒被挂起的线程。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2d1c54893df48bdbae2e58c437f8b29~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h2 id="锁消除" tabindex="-1"><a class="header-anchor" href="#锁消除" aria-hidden="true">#</a> 锁消除</h2><blockquote><p>什么是锁消除？</p></blockquote><p>「锁消除」是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到<strong>不可能存在共享数据竞争的锁进行消除</strong>。</p><p>（不会被其它线程访问的线程没有加锁的必要，于是加锁的的步骤会被消除）</p><p><strong>锁消除的主要判定依据来源于逃逸分析的数据支持</strong>，意思就是：</p><p><code>JVM</code>会判断在一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那<code>JVM</code>就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。</p><p>当然在实际开发中，我们很清楚的知道哪些是线程独有的，不需要加同步锁。</p><p>但是在<code>Java API</code>中有很多方法都是加了同步的，那么此时<code>JVM</code>会判断这段代码是否需要加锁。<strong>如果数据并不会逃逸，则会进行锁消除。</strong></p><ul><li><blockquote><p>比如如下操作</p></blockquote><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">testLockElimination</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">,</span> <span class="token class-name">String</span> s3<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token class-name">String</span> s <span class="token operator">=</span> s1 <span class="token operator">+</span> s2 <span class="token operator">+</span> s3<span class="token punctuation">;</span>
     <span class="token keyword">return</span> s<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在操作<code>String</code>类型数据时，由于<code>String</code>是一个不可变类，对字符串的连接操作总是通过生成的新的<code>String</code>对象来进行的。因此**<code>Javac</code>编译器会对<code>String</code>连接做自动优化。**</p><p>在JDK 1.5之前会使用<code>StringBuffer</code>对象的连续<code>append()</code>操作，在JDK 1.5及以后的版本中，<strong>会转化为<code>StringBuidler</code>对象的连续<code>append()</code>操作。</strong></p><p>使用<code>javap</code>编译结果：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span> <span class="token function">testLockElimination</span><span class="token punctuation">(</span><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>String</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token class-name">Ljava</span><span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">String</span><span class="token punctuation">;</span><span class="token class-name">Ljava</span><span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">String</span><span class="token punctuation">;</span><span class="token class-name">Ljava</span><span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">String</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token class-name">Ljava</span><span class="token operator">/</span>lang<span class="token operator">/</span><span class="token class-name">String</span><span class="token punctuation">;</span>
     flags<span class="token operator">:</span> <span class="token constant">ACC_PUBLIC</span><span class="token punctuation">,</span> <span class="token constant">ACC_STATIC</span>
     <span class="token class-name">Code</span><span class="token operator">:</span>
       stack<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">3</span>
          <span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">new</span>           #<span class="token number">6</span>                  <span class="token comment">// class java/lang/StringBuilder</span>
          <span class="token number">3</span><span class="token operator">:</span> dup
          <span class="token number">4</span><span class="token operator">:</span> invokespecial #<span class="token number">7</span>                  <span class="token comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span>
          <span class="token number">7</span><span class="token operator">:</span> aload_0
          <span class="token number">8</span><span class="token operator">:</span> invokevirtual #<span class="token number">12</span>                 <span class="token comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span>
         <span class="token number">11</span><span class="token operator">:</span> aload_1
         <span class="token number">12</span><span class="token operator">:</span> invokevirtual #<span class="token number">12</span>                 <span class="token comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span>
         <span class="token number">15</span><span class="token operator">:</span> aload_2
         <span class="token number">16</span><span class="token operator">:</span> invokevirtual #<span class="token number">12</span>                 <span class="token comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span>
         <span class="token number">19</span><span class="token operator">:</span> invokevirtual #<span class="token number">13</span>                 <span class="token comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span>
         <span class="token number">22</span><span class="token operator">:</span> astore_3
         <span class="token number">23</span><span class="token operator">:</span> aload_3
         <span class="token number">24</span><span class="token operator">:</span> areturn
       <span class="token class-name">LineNumberTable</span><span class="token operator">:</span>
         line <span class="token number">25</span><span class="token operator">:</span> <span class="token number">0</span>
         line <span class="token number">26</span><span class="token operator">:</span> <span class="token number">23</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>众所周知，<code>StringBuilder</code>不是安全同步的，但是在上述代码中，<code>JVM</code>判断该段代码并不会逃逸，则<strong>将该代码带默认为线程独有的资源，并不需要同步，所以执行了锁消除操作。</strong></p><p>(还有<code>Vector</code>中的各种操作也可实现锁消除。在没有逃逸出数据安全防卫内)</p></li></ul><h2 id="锁粗化" tabindex="-1"><a class="header-anchor" href="#锁粗化" aria-hidden="true">#</a> 锁粗化</h2><blockquote><p>什么是锁粗化？</p></blockquote><p>原则上，我们都知道在加同步锁时，<strong>尽可能的将同步块的作用范围限制到尽量小的范围</strong>(只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。</p><p>大部分上述情况是完美正确的，但是如果<strong>存在连串的一系列操作都对同一个对象反复加锁和解锁</strong>，甚至加锁操作时出现在循环体中的，那<strong>即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作。</strong></p><ul><li><blockquote><p>比如下面的操作</p></blockquote><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">testLockCoarsening</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">,</span> <span class="token class-name">String</span> s3<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
     sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
     sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>  
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在上述的连续<code>append()</code>操作中就属于这类情况。<code>JVM</code>会检测到这样一连串的操作都是对同一个对象加锁，那么**<code>JVM</code>会将加锁同步的范围扩展(粗化)到整个一系列操作的外部，使整个一连串的<code>append()</code>操作只需要加锁一次就可以了。**</p></li></ul><h1 id="重量级锁" tabindex="-1"><a class="header-anchor" href="#重量级锁" aria-hidden="true">#</a> 重量级锁</h1><blockquote><p>什么是重量级锁？</p></blockquote><p>重量级锁对象对应的<code>Mark Word</code>信息：</p><table><thead><tr><th>bit fields</th><th>锁标志位</th></tr></thead><tbody><tr><td>指向互斥锁（重量级锁）的指针（ptr_to_heavyweight_monitor）</td><td>10</td></tr></tbody></table><p>内置锁在Java中被抽象为监视器锁（<code>monitor</code>）。</p><p>在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（<code>mutex</code>）。</p><p>这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为「重量级锁」。</p><p>当重量级锁已被获取时，其它线程要获取该锁都会进入阻塞状态。</p><p>重量级锁还负责实现了<code>Semaphore</code>（信号量）的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步。</p><ul><li><blockquote><p>关于这一点我在我的博客：<a href="https://juejin.cn/post/7158825681898438692" target="_blank" rel="noopener noreferrer">绕不过的并发编程--synchronized原理</a>中有详细的解释</p></blockquote></li></ul><blockquote><p>我们提到很多次重量级锁的开销了，那么重量级锁到底有什么开销呢？</p></blockquote><p>重量级锁的开销包括：</p><ul><li><p>系统调用引起的内核态与用户态切换</p><p>当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行<strong>阻塞</strong>，被阻塞的线程不会消耗CPU。</p><p>但是<strong>阻塞或者唤醒一个线程时，都需要操作系统来帮忙</strong>，这就需要从<strong>用户态</strong>转换到<strong>内核态</strong>，而<strong>转换状态是需要消耗很多时间的</strong>，有可能比用户执行代码的时间还要长。</p></li><li><p>线程阻塞造成的线程切换</p><p>等待获取重量级锁的线程要先进入阻塞状态，这个时候CPU时间片被释放，并分配给其它线程，当重量级锁被释放后该线程又要去竞争，竞争成功CPU时间片要分配给它执行任务，这个过程涉及到了几次线程切换，线程切换是需要开销的。</p></li><li><p>...</p></li></ul><blockquote><p>重量级锁的适用场景</p></blockquote><p>追求吞吐量，且锁占用时间较长。</p><blockquote><p>使用<code>Synchronized</code>还有哪些需要注意的？</p></blockquote><ul><li><p><strong>锁对象不能为空，因为锁的信息都保存在对象头里</strong></p></li><li><p>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</p></li><li><p>避免死锁</p></li><li><p>在能选择的情况下，既不要用<code>Lock</code>也不要用<code>synchronized</code>关键字</p><p>而是用<code>java.util.concurrent</code>包中的各种各样的类</p><p>如果不用该包下的类，在满足业务的情况下，可以使用<code>synchronized</code>关键，因为代码量少，避免出错</p></li></ul><h1 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h1><p>本篇我们针对<code>synchronized</code>关键字底层对锁的优化，依次介绍了自旋锁优化，偏向锁，轻量级锁等等锁优化机制。</p><p>相信通过本篇的学习大家可以对并发编程中的锁有一个比较全面的了解。</p><p>本章参考：</p><ul><li><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener noreferrer">https://tech.meituan.com/2018/11/15/java-lock.html</a></li><li><a href="https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html" target="_blank" rel="noopener noreferrer">https://pdai.tech/md/java/thread/java-thread-x-key-synchronized.html</a></li><li><a href="https://www.jianshu.com/p/d53bf830fa09" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/d53bf830fa09</a></li><li><a href="https://www.cnblogs.com/54chensongxia/p/11899031.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/54chensongxia/p/11899031.html</a></li><li><a href="https://www.jianshu.com/p/5fbe42932f81" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/5fbe42932f81</a></li><li><a href="https://www.cnblogs.com/cxuanBlog/p/11679883.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/cxuanBlog/p/11679883.html</a></li><li><a href="https://juejin.cn/post/6844903550586191885" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844903550586191885</a></li><li><a href="https://gorden5566.com/post/1019.html" target="_blank" rel="noopener noreferrer">https://gorden5566.com/post/1019.html</a></li></ul><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></footer><!----><!--[--><!--]--><!----></main><ul class="catalog" style="top:0px;"><li class="level-2 toc-link-java对象头">Java对象头</li><li class="level-2 toc-link-锁的类型">锁的类型</li><li class="level-2 toc-link-为什么需要锁优化">为什么需要锁优化？</li><li class="level-2 toc-link-自旋锁">自旋锁</li><li class="level-3 toc-link-自适应自旋锁">自适应自旋锁</li><li class="level-2 toc-link-偏向锁">偏向锁</li><li class="level-3 toc-link-锁撤销">锁撤销</li><li class="level-2 toc-link-轻量级锁">轻量级锁</li><li class="level-3 toc-link-轻量级锁加锁">轻量级锁加锁</li><li class="level-3 toc-link-轻量级锁解锁">轻量级锁解锁</li><li class="level-2 toc-link-锁消除">锁消除</li><li class="level-2 toc-link-锁粗化">锁粗化</li></ul></div><!--]--></div><div class="search-page" role="search"><span class="search-close"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" width="28" height="28" fill="currentColor"><path d="M224 416c-8.188 0-16.38-3.125-22.62-9.375l-192-192c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L224 338.8l169.4-169.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-192 192C240.4 412.9 232.2 416 224 416z"></path></svg></span><div class="gungnir-search-box"><input placeholder="$ grep ..." autocomplete="off" spellcheck="false" value><!----></div></div><div class="menu-btn-container"><div class="menu-btn-wrapper"><div class="menu-btn"><div style="" class="menu-btn-icon"><span></span><span></span><span></span></div><div style="display:none;" class="menu-text">0</div><svg class="menu-progress"><circle class="menu-border" cx="50%" cy="50%" r="48%" style="stroke-dasharray:0% 314.15926%;"></circle></svg></div><div class="menu-btn-child-wrapper"><div class="toggle-dark-button menu-btn-child" title="toggle dark mode"><svg class="ov-icon" style="font-size:1.2em;display:none;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"/></svg><svg class="ov-icon" style="font-size:1.2em;display:none;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 00283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"/></svg><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M224 96l16-32 32-16-32-16-16-32-16 32-32 16 32 16 16 32zM80 160l26.66-53.33L160 80l-53.34-26.67L80 0 53.34 53.33 0 80l53.34 26.67L80 160zm352 128l-26.66 53.33L352 368l53.34 26.67L432 448l26.66-53.33L512 368l-53.34-26.67L432 288zm70.62-193.77L417.77 9.38C411.53 3.12 403.34 0 395.15 0c-8.19 0-16.38 3.12-22.63 9.38L9.38 372.52c-12.5 12.5-12.5 32.76 0 45.25l84.85 84.85c6.25 6.25 14.44 9.37 22.62 9.37 8.19 0 16.38-3.12 22.63-9.37l363.14-363.15c12.5-12.48 12.5-32.75 0-45.24zM359.45 203.46l-50.91-50.91 86.6-86.6 50.91 50.91-86.6 86.6z"/></svg></div><div class="menu-btn-child"><svg class="ov-icon" style="font-size:1.7999999999999998em;" aria-hidden="true" width="28.799999999999997" height="28.799999999999997" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"/></svg></div><div class="menu-btn-child"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M240.971 130.524l194.343 194.343c9.373 9.373 9.373 24.569 0 33.941l-22.667 22.667c-9.357 9.357-24.522 9.375-33.901.04L224 227.495 69.255 381.516c-9.379 9.335-24.544 9.317-33.901-.04l-22.667-22.667c-9.373-9.373-9.373-24.569 0-33.941L207.03 130.525c9.372-9.373 24.568-9.373 33.941-.001z"/></svg></div><div class="menu-btn-child menu-toc-btn"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M48 48a48 48 0 1048 48 48 48 0 00-48-48zm0 160a48 48 0 1048 48 48 48 0 00-48-48zm0 160a48 48 0 1048 48 48 48 0 00-48-48zm448 16H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16v-32a16 16 0 00-16-16zm0-320H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16V80a16 16 0 00-16-16zm0 160H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16v-32a16 16 0 00-16-16z"/></svg></div><div class="toggle-sidebar-button menu-btn-child menu-btn-sidebar" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-1.6 -1.6 19.2 19.2" fill="currentColor"><path d="M14 2a1 1 0 011 1v10a1 1 0 01-1 1H2a1 1 0 01-1-1V3a1 1 0 011-1h12zM2 1a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V3a2 2 0 00-2-2H2z"/><path d="M3 4a1 1 0 011-1h2a1 1 0 011 1v8a1 1 0 01-1 1H4a1 1 0 01-1-1V4z"/></svg></div></div></div></div><footer class="footer"><span>
                &copy; pixel-revolve 2021-2022
                <br>
                Powered by <a href="https://vuepress.vuejs.org" target="_blank">VuePress</a> &
                <a href="https://github.com/Renovamen/vuepress-theme-gungnir" target="_blank">Gungnir</a>
                </span></footer></div><!--]--></div>
    <script type="module" src="/assets/app.9fd9aa02.js" defer></script>
  </body>
</html>
