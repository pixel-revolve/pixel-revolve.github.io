<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.38">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/img/logo-broccoli.png"><title>从零开始的JVM学习--Java内存模型（JMM） | pixel-revolve</title><meta name="description" content="爱编程，爱生活">
    <link rel="modulepreload" href="/assets/app.9fd9aa02.js"><link rel="modulepreload" href="/assets/index.html.6c65e070.js"><link rel="modulepreload" href="/assets/index.html.e83a6db5.js">
    <link rel="stylesheet" href="/assets/style.2781e754.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container no-sidebar"><!--[--><header class="navbar invert"><span><a href="/" class=""><span class="site-name">$ cd /home/</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="Home"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/></svg></span><span>Home</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/tags/" class="" aria-label="Tags"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M17.707 9.293a1 1 0 010 1.414l-7 7a1 1 0 01-1.414 0l-7-7A.997.997 0 012 10V5a3 3 0 013-3h5c.256 0 .512.098.707.293l7 7zM5 6a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/></svg></span><span>Tags</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/links/" class="" aria-label="Links"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z" clip-rule="evenodd"/></svg></span><span>Links</span><!--[--><!--]--></a></div><!--]--><div class="navbar-item"><a style="cursor:pointer;"><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 2c4.968 0 9 4.032 9 9s-4.032 9-9 9-9-4.032-9-9 4.032-9 9-9zm0 16c3.867 0 7-3.133 7-7 0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7zm8.485.071l2.829 2.828-1.415 1.415-2.828-2.829 1.414-1.414z"/></svg></span><span>Search</span></a></div></nav><!--[--><!--]--><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="Home"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/></svg></span><span>Home</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/tags/" class="" aria-label="Tags"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M17.707 9.293a1 1 0 010 1.414l-7 7a1 1 0 01-1.414 0l-7-7A.997.997 0 012 10V5a3 3 0 013-3h5c.256 0 .512.098.707.293l7 7zM5 6a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/></svg></span><span>Tags</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/links/" class="" aria-label="Links"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z" clip-rule="evenodd"/></svg></span><span>Links</span><!--[--><!--]--></a></div><!--]--><div class="navbar-item"><a style="cursor:pointer;"><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 2c4.968 0 9 4.032 9 9s-4.032 9-9 9-9-4.032-9-9 4.032-9 9-9zm0 16c3.867 0 7-3.133 7-7 0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7zm8.485.071l2.829 2.828-1.415 1.415-2.828-2.829 1.414-1.414z"/></svg></span><span>Search</span></a></div></nav><!--[--><!--]--><!----><!--[--><!--]--></aside><!--]--><div class="page-content"><!--[--><div class="show-catalog post-wrapper"><div class="article-header use-image post-header" style="background-image:url(/img/blog_cover/2022/10/从零开始的JVM学习--Java内存模型（JMM）.jpg);"><div class="article-header-mask" style="background:rgba(40, 57, 101, .4);"></div><div class="article-header-content"><div class="article-tags"><!--[--><span class="article-tag">JVM</span><!--]--></div><h1 class="article-title">从零开始的JVM学习--Java内存模型（JMM）</h1><p class="article-subtitle">内存模型和Java运行时数据区域要区分好</p><div class="article-icons"><div class="article-icon"><svg class="ov-icon" style="font-size:1.08em;" aria-hidden="true" width="17.28" height="17.28" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M313.6 304c-28.7 0-42.5 16-89.6 16-47.1 0-60.8-16-89.6-16C60.2 304 0 364.2 0 438.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-25.6c0-74.2-60.2-134.4-134.4-134.4zM400 464H48v-25.6c0-47.6 38.8-86.4 86.4-86.4 14.6 0 38.3 16 89.6 16 51.7 0 74.9-16 89.6-16 47.6 0 86.4 38.8 86.4 86.4V464zM224 288c79.5 0 144-64.5 144-144S303.5 0 224 0 80 64.5 80 144s64.5 144 144 144zm0-240c52.9 0 96 43.1 96 96s-43.1 96-96 96-96-43.1-96-96 43.1-96 96-96z"/></svg><span>pixel-revolve</span></div><div class="article-icon"><svg class="ov-icon" style="font-size:1.08em;" aria-hidden="true" width="17.28" height="17.28" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M400 64h-48V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H160V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zm-6 400H54c-3.3 0-6-2.7-6-6V160h352v298c0 3.3-2.7 6-6 6z"/></svg><span>2022-10-03</span></div><div class="article-icon"><svg class="ov-icon" style="font-size:1.08em;" aria-hidden="true" width="17.28" height="17.28" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M17.618 5.968l1.453-1.453 1.414 1.414-1.453 1.453a9 9 0 11-1.414-1.414zM12 20a7 7 0 100-14 7 7 0 000 14zM11 8h2v6h-2V8zM8 1h8v2H8V1z"/></svg><span>36 min</span></div></div></div><!----></div><main class="page post-content"><!--[--><!--]--><div class="theme-gungnir-content"><!--[--><h1 id="简单介绍" tabindex="-1"><a class="header-anchor" href="#简单介绍" aria-hidden="true">#</a> 简单介绍</h1><h2 id="什么是java内存区域" tabindex="-1"><a class="header-anchor" href="#什么是java内存区域" aria-hidden="true">#</a> 什么是Java内存区域?</h2><p>「Java内存区域」也可以叫做「Java运行时数据区域」是指 <code>JVM</code> 运行时会把它管理的内存划分成若干个不同的数据区域 ，简单的说就是不同的数据放在不同的地方。</p><p>所以本篇文章的关键就在正确的描述Java内存区域的划分，以及各个区域的存储内容和解释。</p><blockquote><p>很重要的一点，「Java内存区域」和「Java内存模型」并不是一个东西。</p><p>这一点在我的博客：<a href="">从零开始的JVM学习--Java内存模型（JMM）</a>中有详细的说明。</p></blockquote><h1 id="java内存区域" tabindex="-1"><a class="header-anchor" href="#java内存区域" aria-hidden="true">#</a> Java内存区域</h1><p>「Java内存区域」是对内存的区域<strong>划分</strong>，并且JDK 1.8 的 「Java内存区域」和 JDK 1.8 以前的有所不同。下面我用几张图来描述一下不同版本的「Java内存区域」</p><blockquote><p>JDK 1.8 之前的 Java内存区域</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221004204436881.png" alt="image-20221004204436881"></p><blockquote><p>JDK 1.8 及之后的 Java内存区域</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221004204448375.png" alt="image-20221004204448375"></p><blockquote><p>JDK1.8 之前的 和 JDK1.8 的有什么不同？</p></blockquote><p>JDK 1.8 中「元空间」替代了「方法区」。</p><p>JDK 1.7 其实是并<strong>没完全移除</strong>「方法区」，但是不会像JDK 1.6 以前报 “<code>java.lang.OutOfMemoryError: PermGen space</code>”，而是报 <code>java.lang.OutOfMemoryError: Java heap space</code></p><p>其中在 JDK 1.7 ，「常量池」、「静态变量」，从「方法区」转移到了「堆」。</p><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221004204559206.png" alt="image-20221004204559206"></p><blockquote><p>为什么JDK 1.8中 <code>PermGen</code>（永久代） 被移出 <code>HotSpot JVM</code>了？</p></blockquote><ul><li>由于 <code>PermGen</code> 内存经常会溢出，引发恼人的 <code>java.lang.OutOfMemoryError: PermGen</code>，因此 <code>JVM </code>的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 <code>OOM</code></li><li>移除 <code>PermGen</code> 可以促进 <code>HotSpot JVM</code> 与 <code>JRockit VM</code> 的融合，因为 <code>JRockit</code> 没有永久代。</li></ul><blockquote><p>线程共享，线程私有？</p></blockquote><ul><li><blockquote><p>JDK 1.8 之前</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221004204717948.png" alt="image-20221004204717948"></p><p><strong>线程私有</strong>：</p><ul><li>本地方法栈</li><li>程序计数器</li><li>虚拟机栈</li></ul><p><strong>线程共享</strong>：</p><ul><li><p>堆</p></li><li><p>方法区</p></li></ul></li><li><blockquote><p>JDK 1.8 之后</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221004204729767.png" alt="image-20221004204729767"></p><p><strong>线程私有</strong>：</p><ul><li>本地方法栈</li><li>程序计数器</li><li>虚拟机栈</li></ul><p><strong>线程共享</strong>：</p><ul><li>堆</li><li>元空间</li></ul></li></ul><h2 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器" aria-hidden="true">#</a> 程序计数器</h2><blockquote><p>本章我们将从CPU的程序计数器开始学习，接着将计算机上的进程运行和进程切换恢复场景代入到Java程序中来深入理解程序计数器的作用。</p></blockquote><h3 id="cpu中的程序计数器" tabindex="-1"><a class="header-anchor" href="#cpu中的程序计数器" aria-hidden="true">#</a> CPU中的程序计数器</h3><blockquote><p>什么是CPU的PC？</p></blockquote><p>CPU中的PC是一个大小为一个字的存储设备（寄存器）</p><p>PC中存储的都是内存地址，而CPU就根据PC中的内存地址，到相应的内存取出指令然后执行并且更新PC的值。</p><blockquote><p>操作系统如何管理多进程？</p></blockquote><p>每创建一个进程，操作系统都会为这个进程创建一个<code>PCB</code>（进程控制块）来记录这个进程的信息（比如：PID...）。</p><p>当发生进程切换时，操作系统会在<code>PCB</code>保存进程执行的当前信息（比如：内存，寄存器使用的情况...），在恢复进程的时候，再根据<code>PCB</code>恢复状态。</p><blockquote><p><strong>所以可以发现在计算机上，进程的运行一个是依赖一个「取值」功能，还有就是进程切换恢复的处理。这个场景映射到Java程序的运行和多线程的切换恢复是一样的！</strong></p></blockquote><blockquote><p>讲完CPU中的程序计数器后，那么Java运行时数据区域的「程序计数器」呢？</p></blockquote><h3 id="java内存区域的程序计数器" tabindex="-1"><a class="header-anchor" href="#java内存区域的程序计数器" aria-hidden="true">#</a> Java内存区域的程序计数器</h3><blockquote><p>CPU中PC是一个物理设备，而在Java中PC是一块比较小的内存空间。具体内容将在本章介绍。</p></blockquote><blockquote><p>什么是「程序计数器」？</p></blockquote><p>「程序计数器」是一块较小的内存空间，可以看作是<strong>当前线程所执行的字节码的行号指示器。</strong></p><p>「字节码解释器」工作时通过改变「程序计数器」的值来选取下一条需要执行的字节码指令</p><p>分支、循环、跳转、异常处理、线程恢复等功能都需要<strong>依赖</strong>这个计数器来完成</p><p>为了线程切换后能恢复到正确的执行位置，<strong>每条线程都需要有一个独立的「程序计数器」</strong>，各线程之间计数器互不影响，独立存储，这类内存区域就是所谓“线程私有”的内存。</p><blockquote><p>字节码的执行原理</p></blockquote><p>编译后的字节码在没有经过<code>JIT</code>(实时编译器)编译前，是通过字节码解释器进行解释执行。</p><p>其执行原理为：字节码解释器读取内存中的字节码，按照顺序读取字节码指令，读取一个指令就将其翻译成固定的操作，根据这些操作进行分支，循环，跳转等动作。</p><blockquote><p>程序计数器的作用</p></blockquote><ul><li>「字节码解释器」通过「改变程序计数器」来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，「程序计数器」用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><blockquote><p>程序计数器的特点</p></blockquote><ul><li><p>「程序计数器」具有线程隔离性（线程私有）</p></li><li><p>「程序计数器」的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p></li><li><p>「程序计数器」占用的内存空间非常小，可以忽略不计</p></li><li><p>「程序计数器」是<code>JVM</code>规范中唯一一个没有规定任何<code>OutofMemeryError</code>的区域</p></li><li><p>程序执行的时候，「程序计数器」是有值的，其记录的是程序正在执行的字节码的地址</p></li><li><p>执行<code>native</code>本地方法时，「程序计数器」的值为空。</p><p>原因是<code>native</code>方法是Java通过 <code>JNI</code>(Java Native Interface) 调用本地C/C++库来实现，非Java字节码实现，不受<code>JVM</code>控制。</p></li></ul><h2 id="java-虚拟机栈" tabindex="-1"><a class="header-anchor" href="#java-虚拟机栈" aria-hidden="true">#</a> Java 虚拟机栈</h2><blockquote><p>什么是Java虚拟机栈？</p></blockquote><p>除了一些 <code>native</code>本地方法调用是通过本地方法栈实现的，其他所有的 Java 方法调用都是通过「Java虚拟机栈」来实现的（也需要和其他运行时数据区域比如程序计数器配合）</p><p>「Java虚拟机栈 」<strong>描述的是 Java 方法执行的内存模型</strong>：</p><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221003202541321.png" alt="image-20221003202541321"></p><p>每个方法在执行的同时都会创建一个「栈帧」（Stack Frame）</p><blockquote><p>什么是栈帧？</p></blockquote><p>「栈帧」的结构图:</p><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221003204441592.png" alt="image-20221003204441592"></p><p>「栈帧」存储了方法运行的基础数据结构，包括：</p><ul><li><p><strong>局部变量表</strong></p><blockquote><p>什么是局部变量表？</p></blockquote><p>「局部变量表」 定义为一个数字数组，主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p>「局部变量表」容量大小是在编译期确定下来的。最基本的存储单元是 slot，32 位占用一个 slot，64 位类型（long 和 double）占用两个 slot。</p><blockquote><p>局部变量表有什么用？</p></blockquote><p>当方法运行过程中需要创建局部变量时，就将局部变量的值存入「栈帧」中的「局部变量表」中。</p><p>在「栈帧」中，与性能调优关系最密切的部分，就是「局部变量表」，方法执行时，虚拟机使用「局部变量表」完成方法的传递「局部变量表」中的变量也是重要的垃圾回收根节点，只要被「局部变量表」中直接或间接引用的对象都不会被回收。</p></li><li><p><strong>操作数栈</strong></p><blockquote><p>操作数栈有什么用？</p></blockquote><p>「操作数栈」 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。</p><p>当一个方法刚刚开始执行的时候，这个方法的「操作数栈」是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。</p></li><li><p><strong>动态链接</strong></p><blockquote><p>动态链接有什么用？</p></blockquote><p>「动态链接」主要服务一个方法需要调用其他方法的场景：</p><p>在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为「符号引用」保存在 「Class 文件常量池」里。（ps：在类加载的解析阶段，会将其中的一部分「符号引用」转化为「直接引用」。）</p><p>当一个方法要调用其他方法，需要确定被调用方法的版本（即调用哪一个方法），<strong>将「常量池」中指向方法的「符号引用」转化为其在内存地址中的「直接引用」</strong>。</p><p><strong>「动态链接」的作用就是为了将「符号引用」转换为调用方法的「直接引用」。</strong></p><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221003211903278.png" alt="image-20221003211903278"></p><blockquote><p>这里关于动态链接的内容在「运行时常量池」章节也有提及。</p></blockquote></li><li><p><strong>方法出口</strong></p><blockquote><p>什么是方法出口？</p></blockquote><p>「方法出口」也就是所谓的「方法返回地址」，返回分为 正常返回 和 异常退出。</p><p>无论何种退出情况，都将返回至方法当前被调用的位置，这也程序才能继续执行。方法返回时可能需要在当前「栈帧」中保存一些信息，用来帮他恢复它的上层方法执行状态。</p><p>**方法退出过程实际上就等同于把当前栈帧出栈。**因此退出可以执行的操作有：</p><ul><li>恢复上层方法的「局部变量表」和「操作数栈」</li><li>把返回值(如果有的话) 压入调用者的「操作数栈」中</li><li>调整「PC计数器」的值以指向方法调用指令后的下一条指令</li></ul><p>一般来说，方法正常退出时，调用者的「PC计数器」的值可以作为返回地址，「栈帧」中会保存这个计数器值。</p><p>方法退出的过程相当于弹出当前「栈帧」。</p></li></ul><blockquote><p>压栈出栈过程</p></blockquote><p>「虚拟机栈」可以有很多「栈帧」每一个方法从调用至执行完成的过程，就对应着一个「栈帧」在「Java虚拟机栈」中入栈到出栈的过程。</p><p>在活动线程中，只有位于栈顶的「栈帧」才是有效的，被称为<strong>当前栈帧</strong>，也就是对应的当前执行的方法。</p><p>方法结束后，当前「栈帧」被移出，「栈帧」的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中「操作数栈」的操作数没有变化。</p><blockquote><p>方法调用</p></blockquote><p>关于Java方法调用部分还有一些细节：</p><ul><li><p><strong>静态链接</strong></p><p>当一个字节码文件被装载进 <code>JVM</code> 内部时，如果被调用的目标方法在编译期可知，且运行时期间保持不变，这种情况下降调用方的符号引用转为直接引用的过程称为「静态链接」。</p></li><li><p><strong>动态链接</strong></p><p>如果被调用的方法无法在编译期被确定下来，只能在运行期将调用的方法的符号引用转为直接引用，这种引用转换过程具备动态性，因此被称为「动态链接」。</p></li><li><p><strong>方法绑定</strong></p><ul><li><p><strong>早期绑定：</strong></p><p>被调用的目标方法如果在编译期可知，且运行期保持不变。</p></li><li><p><strong>晚期绑定：</strong></p><p>被调用的方法在编译期无法被确定，只能够在程序运行期根据实际的类型绑定相关的方法。</p></li></ul></li><li><p><strong>非虚方法</strong></p><p>如果方法在编译期就确定了具体的调用版本，则这个版本在运行时是不可变的。这样的方法称为「非虚方法」静态方法，私有方法，final 方法，实例构造器，父类方法都是非虚方法，除了这些以外都是虚方法。</p></li><li><p><strong>虚方法表</strong></p><p>面向对象的编程中，会很频繁的使用动态分配，如果每次动态分配的过程都要重新在类的方法元数据中搜索合适的目标的话，就可能影响到执行效率，因此为了提高性能，<code>JVM</code> 采用在类的方法区建立一个「虚方法表」，使用索引表来代替查找。</p><ul><li>每个类都有一个「虚方法表」，<strong>表中存放着各个方法的实际入口。</strong></li><li>「虚方法表」会在类加载的链接阶段被创建，并开始初始化，类的变量初始值准备完成之后，<code>JVM</code> 会把该类的方法也初始化完毕。</li></ul></li><li><p><strong>方法重写的本质</strong></p><ul><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记做 C。如果在类型 C 中找到与常量池中描述符和简单名称都相符的方法，则进行访问权限校验。</li><li>如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 <code>java.lang.IllegalAccessError</code> 异常。</li><li>否则，按照继承关系从下往上依次对 C 的各个父类进行上一步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出 <code>java.lang.AbstractMethodError</code> 异常。</li></ul></li></ul><p><strong>Java 中任何一个普通方法都具备虚函数的特征（运行期确认，具备晚期绑定的特点）</strong>，C++ 中则使用关键字 virtual 来显式定义。<strong>如果在 Java 程序中，不希望某个方法拥有虚函数的特征，则可以使用关键字 final 来标记这个方法。</strong></p><blockquote><p>Java虚拟机栈的特点</p></blockquote><ul><li><p>「Java虚拟机栈」具有线程隔离性（线程私有）</p></li><li><p>「Java虚拟机栈」的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p></li><li><p>「Java虚拟机栈」运行速度特别快，仅仅次于「程序计数器」。</p></li><li><p>「Java虚拟机栈」会出现两种异常：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</p><ul><li><code>StackOverFlowError</code>： 若 「Java虚拟机栈」的大小不允许动态扩展，那么当线程请求栈的深度超过当前 「Java虚拟机栈」的最大深度时，抛出 <code>StackOverFlowError</code> 异常。</li><li><code>OutOfMemoryError</code> ：若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 <code>OutOfMemoryError </code>异常。</li></ul></li><li><p>出现 <code>StackOverFlowError </code> 异常时，内存空间可能还有很多。</p></li></ul><blockquote><p>常见的运行时异常</p></blockquote><ul><li><code>NullPointerException</code> - 空指针引用异常</li><li><code>ClassCastException</code> - 类型强制转换异</li><li><code>IllegalArgumentException</code> - 传递非法参数异常</li><li><code>ArithmeticException</code> - 算术运算异常</li><li><code>ArrayStoreException</code> - 向数组中存放与声明类型不兼容对象异常</li><li><code>IndexOutOfBoundsException</code> - 下标越界异常</li><li><code>NegativeArraySizeException</code> - 创建一个大小为负数的数组错误异常</li><li><code>NumberFormatException</code> - 数字格式异常</li><li><code>SecurityException</code> - 安全异常</li><li><code>UnsupportedOperationException</code> - 不支持的操作异常</li></ul><h2 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈" aria-hidden="true">#</a> 本地方法栈</h2><blockquote><p>什么是本地方法栈？</p></blockquote><p>「本地方法栈」是为 <code>JVM</code> 运行 <code>native</code> 方法准备的空间，由于很多 <code>native</code> 方法都是用 C 语言实现的，所以它通常又叫 C 栈。</p><p>「本地方法栈」与 「Java虚拟机栈」实现的功能类似，只不过**「本地方法栈」是描述本地方法运行过程的内存模型**。</p><blockquote><p>栈帧变化过程</p></blockquote><p>本地方法被执行时，在「本地方法栈」也会创建一块「栈帧」，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。</p><p>方法执行结束后，相应的「栈帧」也会出栈，并释放内存空间。也会抛出 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 异常。</p><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221004102204635.png" alt="image-20221004102204635"></p><p>如果 <code>JVM</code> 本身不支持 <code>native</code> 方法，或是本身不依赖于传统栈，那么可以不提供「本地方法栈」。如果支持「本地方法栈」，那么这个栈一般会在线程创建的时候按线程分配。</p><h2 id="java-堆" tabindex="-1"><a class="header-anchor" href="#java-堆" aria-hidden="true">#</a> Java 堆</h2><blockquote><p>本章将从简单的介绍堆的基本概念和特点，并简要介绍堆中的内存划分。具体的内容以后在分析垃圾回收的时候会详细说明。</p></blockquote><blockquote><p>什么是堆？</p></blockquote><p>「堆」是用来存放对象的内存空间，<strong>此内存区域的唯一目的就是存放对象实例，「几乎」所有的对象实例以及数组都在这里分配内存。</strong>。</p><p>「堆」是垃圾收集器管理的主要区域，又被称为“GC堆”。</p><blockquote><p>为什么是「几乎」？</p></blockquote><p>随着 <code>JIT</code> 编译器的发展与逃逸分析技术逐渐成熟，「栈」上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到「堆」上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在「栈」上分配内存。</p><blockquote><p>堆的特点</p></blockquote><ul><li><strong>线程共享</strong>，整个 「Java虚拟机」只有一个「堆」，所有的线程都访问同一个「堆」。</li><li>「堆」是「Java虚拟机」管理的内存中最大的一块</li><li>「堆」的大小是可扩展的， 通过<code>-Xmx</code>和<code>-Xms</code>控制。</li><li>「堆」在虚拟机启动时创建。</li><li>「堆」是垃圾回收的主要场所。</li><li>「堆」可分为新生代（Eden 区：<code>From Survior</code>，<code>To Survivor</code>）、老年代。</li><li>「Java虚拟机」规范规定，「堆」可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</li><li>关于 <code>Survivor</code> 区：<code>From Survivor</code>，<code>To Survivor</code>，复制之后有交换，谁空谁是 To。</li><li>如果「堆」内存不够分配实例对象， 并且对也无法在扩展时， 将会抛出<code>OutOfMemoryError</code>异常。</li></ul><blockquote><p>堆内存的划分</p></blockquote><p>在 JDK 1.7 及 JDK 1.7 版本之前，堆内存通常被分成下面的三个部分：</p><ul><li><p>新生代(Young Generation)</p><blockquote><p>什么是新生代？</p></blockquote><p>这块内存我们也叫做<code>Young</code>区</p><p><code>Young</code>区 被划分为三部分，<code>Eden</code>区 和两个大小严格相同的 <code>Survivor</code>区（S0，S1）</p><p><code>Survivor</code>区间中，某一时刻只有其中一个是被使用的，另外一个留做垃圾收集时复制对象用，在<code>Eden</code>区间变满的时候， GC就会将存活的对象移到空闲的<code>Survivor</code>区间中，根据<code>JVM</code>的策略，在经过几次垃圾收集后，任然存活于<code>Survivor</code>的对象将被移动到 <code>Tenured</code> 区间。</p></li><li><p>老生代(Old Generation)</p><blockquote><p>什么是老年代？</p></blockquote><p>这块内存我们也叫做<code>Tenured</code>区</p><p><code>Tenured</code>区 主要保存生命周期长的对象，一般是一些老的对象，当一些对象在<code>Young</code>复制转移一定的次数以后，对象就会被转移到<code>Tenured</code>区，一般如果系统中用了application级别的缓存，缓存中的对象往往会被转移到这一区间。</p></li><li><p>永久代(Permanent Generation)</p><blockquote><p>什么是永久代？</p></blockquote><p>这块内存也是「方法区」在JDK1.7及以前版本的具体实现。我们把它叫做<code>Perm</code>区。</p><p><code>Perm</code>区主要保存<code>class,method,filed</code>对象，这部分的空间一般不会溢出，除非一次性加载了很多的类。</p><p>不过在涉及到<strong>热部署的应用服务器</strong>的时候，有时候会遇到 <code>java.lang.OutOfMemoryError : PermGen space</code> 的错误，造成这个错误的很大原因就有可能是每次都重新部署，但是重新部署后，类的class没有被卸载掉，这样就造成了大量的class对象保存在了<code>Perm</code>中，这种情况下，一般重新启动应用服务器可以解决问题。</p></li></ul><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221004111927894.png" alt="image-20221004111927894"></p><p>JDK1.7：</p><p>堆大小 = 新生代 + 老年代 + 永久代。（ps：堆的大小可通过参数<code>–Xms</code>（堆的初始容量）、<code>-Xmx</code>（堆的最大容量） 来指定）</p><p>在 JDK1.8 中堆内存是由新生代+老年代组成的，<code>Perm</code>区被<code>Metaspace</code>（元空间）代替。<code>Metaspace</code>所占用的内存空间并不是在<code>JVM</code>内部，而是在<strong>本地内存空间</strong>中，这也是和1.7版本的永久代最大的区别：</p><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221004203049566.png" alt="image-20221004203049566"></p><p>在 JDK 1.8 中：</p><p>堆大小 = 新生代 + 老年代。</p><blockquote><p>Virtual 区</p></blockquote><p>最大内存和初始内存的差值，就是<code>Virtual</code>区。</p><p>上面所说的<code>Young</code>区，<code>Tenured</code>区，<code>Perm</code>区都有可能存在<code>Virtual</code>区（即还未被分配的内存）</p><blockquote><p>新生代和老年代</p></blockquote><ul><li><p>「老年代」比「新生代」生命周期长。</p></li><li><p>「新生代」与「老年代」空间默认比例 <code>1:2</code>：</p><p><code>JVM</code> 调参数，<code>XX:NewRatio=2</code>，表示新生代占 1，老年代占 2，「新生代」占整个堆的 1/3，「老年代」占整个堆的 2/3。</p></li><li><p><code>HotSpot</code> 中，<code>Eden</code> 空间和另外两个 <code>Survivor</code> 空间缺省所占的比例是：<code>8:1:1</code>。</p></li><li><p>几乎所有的 Java 对象都是在 <code>Eden</code> 区被 new 出来的，<code>Eden</code> 放不了的大对象，就直接进入「老年代」了。</p></li></ul><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221004113411856.png" alt="image-20221004113411856"></p><h2 id="方法区" tabindex="-1"><a class="header-anchor" href="#方法区" aria-hidden="true">#</a> 方法区</h2><blockquote><p>什么是方法区？</p></blockquote><p>「方法区」属于是 <code>JVM</code> 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。</p><p>《Java 虚拟机规范》规定了有「方法区」这么个概念和它的作用，「方法区」如何实现是虚拟机要考虑的事情。在不同的虚拟机实现上，「方法区」的实现是不同的。所以说**「方法区」是「Java虚拟机」规范中的定义，是一种规范**。</p><p><strong>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到「方法区」</strong>。「方法区」会存储已被虚拟机加载的 类信息、域信息、方法信息、字段信息、常量、静态变量、即时编译器编译后的代码缓存等数据。（方法区中实际存储的信息根据实现的不同也是不同的）</p><blockquote><p>方法区和永久代和元空间的关系</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221005151912150.png" alt="image-20221005151912150"></p><p>「方法区」和「永久代」以及「元空间」的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是「永久代」和「元空间」，接口可以看作是「方法区」，也就是说「永久代」以及「元空间」是 <code>HotSpot</code> 虚拟机对虚拟机规范中「方法区」的两种实现方式。并且，「永久代」是 JDK 1.8 之前的「方法区」实现，JDK 1.8 及以后「方法区」的实现变成了「元空间」。</p><blockquote><p>方法区存放以下信息</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221005150455541.png" alt="image-20221005150455541"></p><ul><li><p><strong>类信息</strong>（类型信息）</p><p>对每个加载的类型( 类class、接口interface、枚举enum、注解annotation)，<code>JVM</code>必须在方法区中存储以下类型信息:</p><ul><li><p>这个类型的完整有效名称(全名-包名.类名)</p></li><li><p>这个类型直接父类的完整有效名(对于interface或是java. lang .object，都没有父类)</p></li><li><p>这个类型的修饰符(public, abstract, final的某个子集)</p></li><li><p>这个类型直接接口的一个有序列表</p></li></ul></li><li><p><strong>域信息</strong></p><p><code>JVM</code>必须在「方法区」中保存类型的所有<strong>域的相关信息</strong>以及<strong>域的声明顺序</strong>。</p><p>域的相关信息包括:</p><ul><li>域名称</li><li>域类型</li><li>域修饰符(public, private,protected, static, final, volatile, transient的某个子集)</li></ul><p>域（Field）= 字段 = 属性 = 成员变量 （一个意思）</p></li><li><p><strong>方法信息</strong></p><p><code>JVM</code>必须保存所有方法的以下信息，和域信息一样包括声明顺序:</p><ul><li><p>方法名称</p></li><li><p>方法的返回类型(或void)</p></li><li><p>方法参数的数量和类型(按顺序)</p></li><li><p>方法的修饰符(public, private, protected, static, final,synchronized, native, abstract的一个子集)</p></li><li><p>方法的字节码(bytecodes)、操作数栈、局部变量表及大小(abstract和native方法除外)</p></li><li><p>异常表( abstract和native方法除外) 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</p></li></ul></li><li><p><strong>方法表</strong></p><p>为了提高访问效率，必须仔细的设计存储在方法区中的数据信息结构。除了以上讨论的结构，<code>JVM</code>的实现者还可以添加一些其他的数据结构，如「方法表」。</p><p><code>JVM</code>对每个加载的非虚拟类的类型信息中都添加了一个「方法表」，「方法表」是一组对类实例方法的直接引用(包括从父类继承的方法。<code>JVM</code>可以通过方法表快速激活实例方法</p></li><li><p><strong>类加载器的引用</strong></p><p><code>JVM</code>必须知道一个类型是由「启动加载器加载」的还是由「用户类加载器」加载的。如果一个类型是由「用户类加载器」加载的，那么<code>JVM</code>会将这个「类加载器」的一个引用作为类型信息的一部分保存在「方法区」中。<code>JVM</code>在「动态链接」的时候需要这个信息。当解析一个类型到另一个类型的引用的时候，<code>JVM</code>需要保证这两个类型的「类加载器」是相同的。这对<code>JVM</code>区分名字空间的方式是至关重要的。</p></li><li><p><strong>Class类实例的引用</strong></p><p><code>JVM</code>为每个加载的类都创建一个<code>java.lang.Class</code>的实例（存储在「堆」上）。而<code>JVM</code>必须以某种方式把Class的这个实例和存储在方法区中的类型数据（类的元数据）联系起来， 因此，<strong>类的元数据里面保存了一个Class对象的引用</strong>；</p><blockquote><p>需要注意的是类元信息和Class对象的不同之处，Class对象是存在</p></blockquote></li><li><p><strong>JIT编译产物</strong></p><p>「JIT编译产物」也可以叫做「JIT代码缓存」，从字面意思理解就是代码缓存区(<code>codeCache</code>)，它缓存的是<code>JIT</code>(Just in Time)即时编译器编译的代码，简言之<code>codeCache</code>是存放JIT生成的机器码(native code)。当然<code>JNI</code>(Java本地接口)的机器码也放在<code>codeCache</code>里，不过<code>JIT</code>编译生成的native code占主要部分。</p><p><code>JVM</code>会对频繁使用的代码，即热点代码(Hot Spot Code)，达到一定的阈值后会编译成本地平台相关的机器码，并进行各层次的优化，提升执行效率。</p><p>热点代码也分两种：</p><ul><li><p>被多次调用的方法</p></li><li><p>被多次执行的循环体</p></li></ul></li><li><p><strong>字段信息</strong></p></li><li><p><strong>静态变量</strong></p></li><li><p><strong>运行时常量池</strong></p><blockquote><p>运行时常量池比较重要，后面将在「运行时常量池」章节详细解释。</p></blockquote></li><li><p>...</p></li></ul><blockquote><p>各个版本的方法区区别</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221006143039693.png" alt="image-20221006143039693"></p><table><thead><tr><th>版本</th><th>变化</th></tr></thead><tbody><tr><td>JDK1.6及之前</td><td>有永久代(permanent generation)，静态变量存放在永久代上</td></tr><tr><td>JDK1.7</td><td>有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中</td></tr><tr><td>JDK1.8及之后</td><td>无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆</td></tr></tbody></table><blockquote><p>方法区的特点</p></blockquote><ul><li><p>「方法区」与「堆」一样，是各个<strong>线程共享</strong>的内存区域。</p></li><li><p>「方法区」在<code>JVM</code>启动的时候被创建，并且它的实际的物理内存空间中和「堆」一样都可以是不连续的。</p></li><li><p>「方法区」的大小，跟堆空间一样，可以选择固定大小或者可扩展。</p></li><li><p>「方法区」的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致「方法区」溢出，虚拟机同样会抛出内存溢出错误:</p><ul><li><code>java.lang.OutOfMemoryError:PermGen space</code> （jdk7前）</li><li><code>java.lang.OutOfMemoryError:Metaspace</code>（jdk8后）</li></ul><p>溢出场景：</p><ul><li>加载大量的第三方的jar包;</li><li>Tomcat部署的工程过多(30-50个)</li><li>大量动态的生成反射类</li></ul></li><li><p>关闭<code>JVM</code>就会释放这个区域的内存。</p></li></ul><h3 id="运行时常量池" tabindex="-1"><a class="header-anchor" href="#运行时常量池" aria-hidden="true">#</a> 运行时常量池</h3><blockquote><p>在学习运行时常量池之前我们先理解常量的概念</p></blockquote><p>常量</p><p>Java中是指以<code>final</code>关键字修饰的变量。</p><p>由于<code>final</code>的不可改变性，因此<code>final</code>类变量的值在编译期间就被确定了。因此被保存在类的「常量池」里面，然后在加载类的时候，复制进方法区的「运行时常量池」里面 ；<code>final</code>类变量存储在「运行时常量池」里面，每一个使用它的类保存着一个对其的引用</p><blockquote><p>什么是运行时常量池？</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221005154527451.png" alt="image-20221005154527451"></p><p>「运行时常量池」(Runtime Constant Pool) 是「方法区」的一部分。在加载类和接口到虚拟机后，就会创建对应的「运行时常量池」。</p><p>为什么叫「运行时常量池」呢？</p><p><strong>是因为运行期间可能会把新的常量放入池中</strong>，比如说常见的<code>String</code>的<code>intern()</code>方法。也因此「运行时常量池」相对于「Class 文件常量池」的一个重要特征就是”动态性“。</p><p>「运行时常量池」中包含多种不同的常量，包括编译期就已经明确的数值「字面量」，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p><p>当创建类或接口的「运行时常量池」时，如果构造「运行时常量池」所需的内存空间超过了方法区所能提供的最大值，则<code>JVM</code> 会抛 <code>OutofMemoryError </code>异常。</p><blockquote><p>字面量</p></blockquote><p>「字面量」一般可以分成以下几种：</p><ul><li>文本字符串</li><li>声明为final的常量值</li><li>基本数据类型的值等</li></ul><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//a为常量，10为字面量</span>
<span class="token class-name">String</span> b <span class="token operator">=</span> “hello world！”<span class="token punctuation">;</span> <span class="token comment">// b 为变量，hello world！为字面量</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>符号引用</p></blockquote><p>「符号引用」包括：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p><strong>「符号引用」以一组符号来描述所引用的目标，符号可以是任何形式的「字面量」，只要使用时能够无歧义的定位到目标即可。</strong></p><p>「符号引用」与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。</p><p>在Java中，一个Java类将会编译成一个class文件。在编译时，Java类并不知道所引用的类的实际地址，因此只能使用「符号引用」来代替。</p><ul><li><blockquote><p>例子</p></blockquote><p><code>org.example.People</code>类引用了<code>org.example.Language</code>类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号<code>org.example.Language</code>来表示Language类的地址。</p></li></ul><p>各种虚拟机实现的内存布局可能有所不同，但是它们能接受的「符号引用」都是一致的，因为「符号引用」的「字面量」形式明确定义在<code>JVM</code>规范的Class文件格式中。</p><ul><li><blockquote><p>直接引用</p></blockquote><p>和「符号引用」，相对的就是「直接引用」了。</p><p>「直接引用」是和虚拟机的布局相关的，同一个「符号引用」在不同的虚拟机实例上翻译（「动态链接」）出来的「直接引用」一般不会相同。</p><p>如果有了「直接引用」，那引用的目标必定已经被加载入内存中了。</p><p>直接引用的实现方式：</p><ul><li>直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）</li><li>相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）</li><li>一个能间接定位到目标的句柄。</li></ul></li></ul><blockquote><p>常量池</p></blockquote><p>要弄清楚「方法区」，需要理解清楚Class文件，因为加载类的信息都在「方法区」。</p><p>要弄清楚「方法区」的「运行时常量池」，需要理解清楚Class文件中的「常量池」。</p><p>（ps: Class文件就是所谓的字节码文件）</p><ul><li><blockquote><p>什么是常量池？</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221006141711482.png" alt="image-20221006141711482"></p><p>「运行时常量池」和这里的「常量池」不是一个东西！</p><p>我们这里讲的「常量池」(Class 常量池)， 是Class文件的一部分。</p><p>Java文件被编译成 Class文件，Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是「常量池」（Constant pool），<strong>用于存放编译期生成的各种「字面量」与「符号引用」，这部分内容将在类加载后存放到方法区的「运行时常量池」中。</strong></p><p><strong>「常量池」可以看做是一张表</strong>，虚拟机指令会根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p></li><li><blockquote><p>为什么需要常量池？</p></blockquote><p>一个Java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到「常量池」，这个字节码包含了指向「常量池」的引用。在「动态链接」的时候会用到「运行时常量池」</p><blockquote><p>这个在「Java 虚拟机栈」章节也有提及。</p></blockquote></li></ul><h3 id="字符串常量池" tabindex="-1"><a class="header-anchor" href="#字符串常量池" aria-hidden="true">#</a> 字符串常量池</h3><blockquote><p>什么是字符串常量池?</p></blockquote><p>「字符串常量池」也可以叫做全局字符串池，英文叫做 String Pool 或 String Table。</p><p>String类是我们使用频率非常高的一种对象类型。<code>JVM</code>为了提升性能和减少内存开销，避免字符串的重复创建，其维护了一块特殊的内存空间。</p><p>「字符串常量池」由String类私有的维护。「字符串常量池」存放的是字符串的引用或者字符串。</p><p><code>JVM</code>在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。</p><p>「常量池」用于存放编译期生成的各种「字面量」和「符号引用」，而当类加载到内存中后，<code>JVM</code>就会将「常量池」中的内容存放到「运行时常量池」中，而字符串常量存在「堆」中「字符串常量池」中（JDK1.7及以后）。</p><blockquote><p>String.intern()方法</p></blockquote><p>直接使用双引号声明出来的<code>String</code>对象会直接存储在「常量池」中。</p><p>如果不是用双引号声明的<code>String</code>对象，可以使用<code>String</code>提供的<code>intern</code>方法。<code>intern</code> 方法会从「字符串常量池」中查询当前字符串是否存在，若不存在就会将当前字符串放入「常量池」中</p><blockquote><p>字符串常量池为什么要移动到堆？</p></blockquote><p>JDK1.7 中将 <code>String Table</code> 放到了「堆」空间中。因为永久代的回收效率很低，在 <code>full gc</code> 的时候才会触发。</p><p><code>full gc</code> 是老年代的空间不足、永久代不足时才会触发。这就导致 <code>StringTable</code> 回收效率不高。</p><p><strong>我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到「堆」里，能及时回收内存。</strong></p><blockquote><p>关于字符串常量池的详细内容以后我会再写博客解释。</p></blockquote><h3 id="元空间" tabindex="-1"><a class="header-anchor" href="#元空间" aria-hidden="true">#</a> 元空间</h3><blockquote><p>元空间和永久代的区别</p></blockquote><ul><li><p><strong>存储位置不同</strong>：</p><p>永久代在<strong>物理上是堆的一部分</strong>，和新生代、老年代的地址是连续的，而「元空间」属于<strong>本地内存</strong>。</p></li><li><p><strong>存储内容不同</strong>：</p><p>在原来的永久代划分中，永久代用来存放类的元数据信息、静态变量以及常量池等。<strong>现在类的元信息存储在「元空间」中，静态变量和常量池等并入堆中</strong>，相当于原来的永久代中的数据，被「元空间」和堆内存给瓜分了。</p></li></ul><blockquote><p>为什么要废弃永久代，引入元空间？JDK版本升级对方法区实现的改进？</p></blockquote><p>相比于之前的永久代划分，Oracle为什么要做这样的改进呢？</p><ul><li><p>在原来的永久代划分中，永久代需要存放类的元数据、静态变量和常量等。<strong>它的大小不容易确定</strong>，因为这其中有很多影响因素，比如类的总数，常量池的大小和方法数量等，<code>-XX:MaxPermSize</code> 指定太小很容易造成永久代内存溢出。</p><p>废除永久代后，<strong>类的元数据</strong>分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。不会遇到永久代存在时的内存溢出错误。</p></li><li><p>移除永久代是为融合<code>HotSpot VM</code>与 <code>JRockit VM</code>而做出的努力，因为<code>JRockit</code>没有永久代，不需要配置永久代。</p></li><li><p>永久代会为<code>GC</code>带来不必要的复杂度，并且回收效率偏低。</p><p>类的元数据从<code>PermGen</code>剥离出来到<code>Metaspace</code>，可以提升对元数据的管理同时提升<code>GC</code>效率。</p></li><li><p>废除永久代后，将运行时常量池从<code>PermGen</code>分离出来，与类的元数据分开，提升类元数据的独立性。</p></li></ul><blockquote><p>元空间相关参数</p></blockquote><ul><li><p><code>-XX:MetaspaceSize</code></p><p>初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时<code>GC</code>会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过<code>MaxMetaspaceSize</code>时，适当提高该值。</p></li><li><p><code>-XX:MaxMetaspaceSize</code></p><p>最大空间，默认是没有限制的。如果没有使用该参数来设置类的元数据的大小，<strong>其最大可利用空间是整个系统内存的可用空间。</strong><code>JVM</code>也可以增加本地内存空间来满足类元数据信息的存储。但是如果没有设置最大值，则可能存在bug导致<code>Metaspace</code>的空间在不停的扩展，会导致机器的内存不足；进而可能出现swap内存被耗尽；最终导致进程直接被系统直接kill掉。如果设置了该参数，当<code>Metaspace</code>剩余空间不足，会抛出<code>java.lang.OutOfMemoryError: Metaspace space</code></p></li><li><p><code>-XX:MinMetaspaceFreeRatio</code></p><p>在<code>GC</code>之后，最小的<code>Metaspace</code>剩余空间容量的百分比，减少为分配空间所导致的垃圾收集。</p></li><li><p><code>-XX:MaxMetaspaceFreeRatio</code></p><p>在<code>GC</code>之后，最大的<code>Metaspace</code>剩余空间容量的百分比，减少为释放空间所导致的垃圾收集。</p></li></ul><h1 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h1><p>Java内存区域，一般也叫做Java运行时数据区域。是理解<code>JVM</code>各种机制的基础。毕竟所有的操作最终都是在和内存进行交互，因此理解内存很重要。</p><p>本篇原来打算2天写完但没想到内容意外的多，花了不少时间，才终于发出来。希望能对这个知识点的总结有帮助。</p><p>本文参考：</p><ul><li><p>https://cloud.tencent.com/developer/article/1748395</p></li><li><p>https://javaguide.cn/java/jvm/memory-area.html</p></li><li><p>https://juejin.cn/post/6844903988781907981</p></li><li><p>https://www.jianshu.com/p/7d9e64973444</p></li><li><p>https://www.zhihu.com/question/456026457</p></li><li><p>https://blog.csdn.net/u011069294/article/details/107415210</p></li><li><p>https://segmentfault.com/a/1190000024447450</p></li><li><p>https://zhuanlan.zhihu.com/p/78473188</p></li><li><p>https://doocs.github.io/jvm/01-jvm-memory-structure.html</p></li><li><p>https://blog.csdn.net/csdn_xby/article/details/105476673</p></li><li><p>https://www.361shipin.com/blog/1532261067982372864</p></li><li><p>https://www.cnblogs.com/ITPower/p/7929010.html#</p></li><li><p>https://juejin.cn/post/6995361827055992863</p></li></ul><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></footer><!----><!--[--><!--]--><!----></main><ul class="catalog" style="top:0px;"><li class="level-2 toc-link-什么是java内存区域">什么是Java内存区域?</li><li class="level-2 toc-link-程序计数器">程序计数器</li><li class="level-3 toc-link-cpu中的程序计数器">CPU中的程序计数器</li><li class="level-3 toc-link-java内存区域的程序计数器">Java内存区域的程序计数器</li><li class="level-2 toc-link-java-虚拟机栈">Java 虚拟机栈</li><li class="level-2 toc-link-本地方法栈">本地方法栈</li><li class="level-2 toc-link-java-堆">Java 堆</li><li class="level-2 toc-link-方法区">方法区</li><li class="level-3 toc-link-运行时常量池">运行时常量池</li><li class="level-3 toc-link-字符串常量池">字符串常量池</li><li class="level-3 toc-link-元空间">元空间</li></ul></div><!--]--></div><div class="search-page" role="search"><span class="search-close"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" width="28" height="28" fill="currentColor"><path d="M224 416c-8.188 0-16.38-3.125-22.62-9.375l-192-192c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L224 338.8l169.4-169.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-192 192C240.4 412.9 232.2 416 224 416z"></path></svg></span><div class="gungnir-search-box"><input placeholder="$ grep ..." autocomplete="off" spellcheck="false" value><!----></div></div><div class="menu-btn-container"><div class="menu-btn-wrapper"><div class="menu-btn"><div style="" class="menu-btn-icon"><span></span><span></span><span></span></div><div style="display:none;" class="menu-text">0</div><svg class="menu-progress"><circle class="menu-border" cx="50%" cy="50%" r="48%" style="stroke-dasharray:0% 314.15926%;"></circle></svg></div><div class="menu-btn-child-wrapper"><div class="toggle-dark-button menu-btn-child" title="toggle dark mode"><svg class="ov-icon" style="font-size:1.2em;display:none;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"/></svg><svg class="ov-icon" style="font-size:1.2em;display:none;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 00283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"/></svg><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M224 96l16-32 32-16-32-16-16-32-16 32-32 16 32 16 16 32zM80 160l26.66-53.33L160 80l-53.34-26.67L80 0 53.34 53.33 0 80l53.34 26.67L80 160zm352 128l-26.66 53.33L352 368l53.34 26.67L432 448l26.66-53.33L512 368l-53.34-26.67L432 288zm70.62-193.77L417.77 9.38C411.53 3.12 403.34 0 395.15 0c-8.19 0-16.38 3.12-22.63 9.38L9.38 372.52c-12.5 12.5-12.5 32.76 0 45.25l84.85 84.85c6.25 6.25 14.44 9.37 22.62 9.37 8.19 0 16.38-3.12 22.63-9.37l363.14-363.15c12.5-12.48 12.5-32.75 0-45.24zM359.45 203.46l-50.91-50.91 86.6-86.6 50.91 50.91-86.6 86.6z"/></svg></div><div class="menu-btn-child"><svg class="ov-icon" style="font-size:1.7999999999999998em;" aria-hidden="true" width="28.799999999999997" height="28.799999999999997" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"/></svg></div><div class="menu-btn-child"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M240.971 130.524l194.343 194.343c9.373 9.373 9.373 24.569 0 33.941l-22.667 22.667c-9.357 9.357-24.522 9.375-33.901.04L224 227.495 69.255 381.516c-9.379 9.335-24.544 9.317-33.901-.04l-22.667-22.667c-9.373-9.373-9.373-24.569 0-33.941L207.03 130.525c9.372-9.373 24.568-9.373 33.941-.001z"/></svg></div><div class="menu-btn-child menu-toc-btn"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M48 48a48 48 0 1048 48 48 48 0 00-48-48zm0 160a48 48 0 1048 48 48 48 0 00-48-48zm0 160a48 48 0 1048 48 48 48 0 00-48-48zm448 16H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16v-32a16 16 0 00-16-16zm0-320H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16V80a16 16 0 00-16-16zm0 160H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16v-32a16 16 0 00-16-16z"/></svg></div><div class="toggle-sidebar-button menu-btn-child menu-btn-sidebar" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-1.6 -1.6 19.2 19.2" fill="currentColor"><path d="M14 2a1 1 0 011 1v10a1 1 0 01-1 1H2a1 1 0 01-1-1V3a1 1 0 011-1h12zM2 1a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V3a2 2 0 00-2-2H2z"/><path d="M3 4a1 1 0 011-1h2a1 1 0 011 1v8a1 1 0 01-1 1H4a1 1 0 01-1-1V4z"/></svg></div></div></div></div><footer class="footer"><span>
                &copy; pixel-revolve 2021-2022
                <br>
                Powered by <a href="https://vuepress.vuejs.org" target="_blank">VuePress</a> &
                <a href="https://github.com/Renovamen/vuepress-theme-gungnir" target="_blank">Gungnir</a>
                </span></footer></div><!--]--></div>
    <script type="module" src="/assets/app.9fd9aa02.js" defer></script>
  </body>
</html>
