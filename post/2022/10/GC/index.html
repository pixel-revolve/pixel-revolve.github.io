<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.38">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/img/logo-broccoli.png"><title>从零开始的JVM学习--GC | pixel-revolve</title><meta name="description" content="爱编程，爱生活">
    <link rel="modulepreload" href="/assets/app.9fd9aa02.js"><link rel="modulepreload" href="/assets/index.html.9fbe647e.js"><link rel="modulepreload" href="/assets/index.html.4e8067b4.js">
    <link rel="stylesheet" href="/assets/style.2781e754.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container no-sidebar"><!--[--><header class="navbar invert"><span><a href="/" class=""><span class="site-name">$ cd /home/</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="Home"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/></svg></span><span>Home</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/tags/" class="" aria-label="Tags"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M17.707 9.293a1 1 0 010 1.414l-7 7a1 1 0 01-1.414 0l-7-7A.997.997 0 012 10V5a3 3 0 013-3h5c.256 0 .512.098.707.293l7 7zM5 6a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/></svg></span><span>Tags</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/links/" class="" aria-label="Links"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z" clip-rule="evenodd"/></svg></span><span>Links</span><!--[--><!--]--></a></div><!--]--><div class="navbar-item"><a style="cursor:pointer;"><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 2c4.968 0 9 4.032 9 9s-4.032 9-9 9-9-4.032-9-9 4.032-9 9-9zm0 16c3.867 0 7-3.133 7-7 0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7zm8.485.071l2.829 2.828-1.415 1.415-2.828-2.829 1.414-1.414z"/></svg></span><span>Search</span></a></div></nav><!--[--><!--]--><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="Home"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/></svg></span><span>Home</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/tags/" class="" aria-label="Tags"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M17.707 9.293a1 1 0 010 1.414l-7 7a1 1 0 01-1.414 0l-7-7A.997.997 0 012 10V5a3 3 0 013-3h5c.256 0 .512.098.707.293l7 7zM5 6a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/></svg></span><span>Tags</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/links/" class="" aria-label="Links"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z" clip-rule="evenodd"/></svg></span><span>Links</span><!--[--><!--]--></a></div><!--]--><div class="navbar-item"><a style="cursor:pointer;"><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 2c4.968 0 9 4.032 9 9s-4.032 9-9 9-9-4.032-9-9 4.032-9 9-9zm0 16c3.867 0 7-3.133 7-7 0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7zm8.485.071l2.829 2.828-1.415 1.415-2.828-2.829 1.414-1.414z"/></svg></span><span>Search</span></a></div></nav><!--[--><!--]--><!----><!--[--><!--]--></aside><!--]--><div class="page-content"><!--[--><div class="show-catalog post-wrapper"><div class="article-header use-image post-header" style="background-image:url(/img/blog_cover/2022/10/从零开始的JVM学习--GC.png);"><div class="article-header-mask" style="background:rgba(40, 57, 101, .4);"></div><div class="article-header-content"><div class="article-tags"><!--[--><span class="article-tag">JVM</span><!--]--></div><h1 class="article-title">从零开始的JVM学习--GC</h1><p class="article-subtitle">垃圾回收机制</p><div class="article-icons"><div class="article-icon"><svg class="ov-icon" style="font-size:1.08em;" aria-hidden="true" width="17.28" height="17.28" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M313.6 304c-28.7 0-42.5 16-89.6 16-47.1 0-60.8-16-89.6-16C60.2 304 0 364.2 0 438.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-25.6c0-74.2-60.2-134.4-134.4-134.4zM400 464H48v-25.6c0-47.6 38.8-86.4 86.4-86.4 14.6 0 38.3 16 89.6 16 51.7 0 74.9-16 89.6-16 47.6 0 86.4 38.8 86.4 86.4V464zM224 288c79.5 0 144-64.5 144-144S303.5 0 224 0 80 64.5 80 144s64.5 144 144 144zm0-240c52.9 0 96 43.1 96 96s-43.1 96-96 96-96-43.1-96-96 43.1-96 96-96z"/></svg><span>pixel-revolve</span></div><div class="article-icon"><svg class="ov-icon" style="font-size:1.08em;" aria-hidden="true" width="17.28" height="17.28" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M400 64h-48V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H160V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zm-6 400H54c-3.3 0-6-2.7-6-6V160h352v298c0 3.3-2.7 6-6 6z"/></svg><span>2022-10-11</span></div><div class="article-icon"><svg class="ov-icon" style="font-size:1.08em;" aria-hidden="true" width="17.28" height="17.28" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M17.618 5.968l1.453-1.453 1.414 1.414-1.453 1.453a9 9 0 11-1.414-1.414zM12 20a7 7 0 100-14 7 7 0 000 14zM11 8h2v6h-2V8zM8 1h8v2H8V1z"/></svg><span>39 min</span></div></div></div><!----></div><main class="page post-content"><!--[--><!--]--><div class="theme-gungnir-content"><!--[--><h1 id="简单介绍" tabindex="-1"><a class="header-anchor" href="#简单介绍" aria-hidden="true">#</a> 简单介绍</h1><h2 id="什么是垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#什么是垃圾回收机制" aria-hidden="true">#</a> 什么是垃圾回收机制？</h2><blockquote><p>什么是垃圾回收机制？</p></blockquote><p>Java语言的一个显著的特点就是引入了「垃圾回收机制」，使C++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候<strong>不再需要考虑内存管理。</strong></p><p>由于有个「垃圾回收机制」，Java中的对象不再有“作用域的概念，只有对象的引用才有“作用域”。</p><p>「垃圾回收器」通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用「垃圾回收器」对某个对象或所有对象进行垃圾回收（自动执行，且不可控）。</p><p>「回收机制」有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。「垃圾回收器」通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用「垃圾回收器」对某个对象或所有对象进行垃圾回收（自动执行，且不可控）。</p><p>「回收机制」有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。</p><p><strong>「垃圾回收」可以有效的防止内存泄露，有效的使用可以使用的内存。</strong></p><h2 id="java-堆的内存结构" tabindex="-1"><a class="header-anchor" href="#java-堆的内存结构" aria-hidden="true">#</a> Java 堆的内存结构</h2><blockquote><p>关于Java 堆的内存结构的具体内容可以看我的这篇博客：<a href="https://juejin.cn/post/7151302259605766157" target="_blank" rel="noopener noreferrer">从零开始的JVM学习--Java运行时数据区域</a></p></blockquote><blockquote><p>理解堆内存结构对垃圾回收机制有什么用？</p></blockquote><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。并且我们知道Java对象是存储在「堆」中的，所以Java 自动内存管理最核心的功能是「堆」内存中对象的分配与回收。</p><p>「堆」是「垃圾收集器」管理的主要区域，因此也被称为“垃圾堆”（<code>GC</code>堆）。</p><p>程序计数器、虚拟机栈、本地方法栈随线程而生，也随线程而灭；栈帧随着方法的开始而入栈，随着方法的结束而出栈。<strong>这几个区域的内存分配和回收都具有确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</strong></p><p><strong>而对于「堆」和「方法区」，我们只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的</strong>，「垃圾收集器」所关注的正是这部分内存（也就是线程共享的几个区域）。</p><blockquote><p>JDK1.7 及以前的堆结构</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221007140928421.png" alt="image-20221007140928421"></p><ul><li>新生代 <ul><li><code>Eden</code> 区</li><li>两个 <code>Survivor</code> 区</li></ul></li><li>老年代</li><li>永久代</li></ul><blockquote><p>JDK1.8 的堆结构</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221007140941753.png" alt="image-20221007140941753"></p><p>JDK1.8 开始，<code>PermGen</code>（永久代）被 <code>MetaSpace</code>（元空间）替代，元空间使用的是<strong>直接内存</strong>。</p><h1 id="垃圾收集" tabindex="-1"><a class="header-anchor" href="#垃圾收集" aria-hidden="true">#</a> 垃圾收集</h1><h2 id="哪些内存需要回收" tabindex="-1"><a class="header-anchor" href="#哪些内存需要回收" aria-hidden="true">#</a> 哪些内存需要回收？</h2><h3 id="判断对象是否可以被回收" tabindex="-1"><a class="header-anchor" href="#判断对象是否可以被回收" aria-hidden="true">#</a> 判断对象是否可以被回收</h3><h4 id="引用计数法" tabindex="-1"><a class="header-anchor" href="#引用计数法" aria-hidden="true">#</a> 引用计数法</h4><blockquote><p>什么是引用计数法？</p></blockquote><p>在对象头维护着一个 counter 计数器，对象被引用一次则计数器 +1；若引用失效则计数器 -1。当计数器为 0 时，就认为该对象无效了可以回收。</p><blockquote><p>引用计数算法的缺点</p></blockquote><ul><li>需要额外的内存来计数</li><li>运行期间需要维护计数器，带来额外的开销</li><li>无法解决循环引用的问题</li></ul><blockquote><p>主流 JVM 为什么不用引用计数算法？</p></blockquote><p>「引用计数算法」的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是主流的<code>JVM</code>里没有选用「引用计数算法」来管理内存，主要是<strong>因为它很难解决对象之间「循环引用」的问题</strong>。</p><blockquote><p>循环引用问题</p></blockquote><p>在两个对象出现「循环引用」的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为「循环引用」的存在，<code>JVM</code>不使用「引用计数算法」。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token class-name">Object</span> instance <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Test</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 引用+1</span>
        <span class="token class-name">Test</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 引用+1</span>
        a<span class="token punctuation">.</span>instance <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token comment">// 引用+1</span>
        b<span class="token punctuation">.</span>instance <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token comment">// 引用+1</span>
        a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// 引用-1</span>
        b <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">// 引用-1</span>
        <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// a、b均不可能再被访问到，但是引用计数器为1，无法被回收。</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>a 与 b 引用的对象实例互相持有了对方的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。这样就造成了内存的泄漏了。</p><h4 id="可达性分析法" tabindex="-1"><a class="header-anchor" href="#可达性分析法" aria-hidden="true">#</a> 可达性分析法</h4><p>主流<code>JVM</code>都是通过可达性分析来判断对象是否可以被回收的。</p><blockquote><p>什么是可达性分析算法？</p></blockquote><p>「可达性分析算法」<strong>以 <code>GC Roots</code> 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</strong></p><p>搜索走过的路径称为「引用链」，所以算法也可以总结为：如果某个对象到<code>GC Roots</code>没有任何「引用链」相连，就说明该对象不可达，即可以被回收。</p><p><code>JVM</code> 使用该算法来判断对象是否可被回收。</p><blockquote><p>什么是 GC Roots？</p></blockquote><p><strong><code>GC Roots</code>就是对象，而且是<code>JVM</code>确定当前绝对不能被回收的对象（如方法区中类静态属性引用的对象 ）。</strong></p><blockquote><p>只有找到这种对象，后面的搜索过程才有意义，<strong>不能被回收的对象所依赖的其他对象肯定也不能回收。</strong></p></blockquote><blockquote><p>可达性算法搜索的过程</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221007163716530.png" alt="image-20221007163716530"></p><p>当<code>JVM</code>触发<code>GC</code>时，首先会让所有的用户线程到达安全点<code>SafePoint</code>时阻塞（暂停用户线程），也就是<code>STW</code>(stop the world)。</p><p>然后<code>JVM</code>要找到所有的<code>GC Roots</code>，这个过程也称作「枚举根节点」。</p><p><strong>然后就可以从这些<code>GC Roots</code>向下搜寻，可达的对象就保留，不可达的对象就回收。</strong></p><blockquote><p>GC Roots一般可以是什么样的对象？</p></blockquote><p><code>GC Roots</code> 是一种特殊的对象，是Java程序在运行过程中所必须的对象，而且是根对象。</p><p>作为根肯定是满足一定条件的，使它向上查找不到结果，也就是<strong>具备最大性</strong>。<code>GC Roots</code>一般是以下对象：</p><ul><li><p><strong>「虚拟机栈」中「局部变量表」中引用的对象</strong></p><p>属于执行上下文中的对象。线程在执行方法时，会将方法打包成一个栈帧入栈执行，方法里用到的局部变量会存放到栈帧的「局部变量表」中。</p><p>只要方法还在运行，还没出栈，就意味这「局部变量表」的对象还会被访问，<code>GC</code>就不应该回收，所以这一类对象也可作为<code>GC Roots</code>。</p></li><li><p><strong>「本地方法栈」中 <code>JNI</code> 中引用的对象</strong></p><p>和上一条本质相同，无非是一个是Java虚拟机栈中的变量引用，一个是「本地方法栈」中的变量引用。</p></li><li><p><strong>「方法区」中类静态属性引用的对象</strong></p><p>属于全局对象。Class对象本身很难被回收，回收的条件非常苛刻，只要Class对象不被回收，静态成员就不能被回收。</p></li><li><p><strong>「方法区」中的常量池引用的对象</strong></p><p>属于全局对象。比如字符串常量池，常量本身初始化后就不再改变，因此作为<code>GC Roots</code>也是合理的。</p></li><li><p><strong>被同步锁持有的对象</strong></p><p>被 <code>synchronized</code> 锁住的对象不能被回收的。当前有线程持有对象锁，如果<code>GC</code>回收了对象，锁就失效了。</p></li></ul><p><code>GC Roots</code> 并不包括「堆」中对象所引用的对象，这样就不会有循环引用的问题。</p><h3 id="引用类型" tabindex="-1"><a class="header-anchor" href="#引用类型" aria-hidden="true">#</a> 引用类型</h3><blockquote><p>什么是引用类型？</p></blockquote><p>在 JDK 1.2 以前，Java 中的引用定义很传统，一个对象只有被引用或者没有被引用两种状态。</p><p>但是我们希望能描述这一类对象：</p><p><strong>当内存空间还足够时，则保留在内存中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。</strong>（很多系统的缓存功能都符合这样的应用场景）</p><p>在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为了以下四种：</p><ul><li>强引用（Strong Reference）</li><li>软引用（Soft Reference）</li><li>弱引用（Weak Reference）</li><li>虚引用（Phantom Reference）</li></ul><p>这也就是我们这里所要介绍的「引用类型」了。</p><blockquote><p>引用类型有什么用？</p></blockquote><p><strong>判定对象是否「存活」和「引用」有关</strong>。</p><p>无论是通过「引用计数算法」判断对象的引用数量，还是通过「可达性分析算法」判断对象是否可达，判定对象是否可被回收都与「引用」有关。</p><p>以上所列举的不同的「引用类型」，<strong>主要体现的是对象不同的「可达性状态」和「垃圾收集」的影响</strong>。</p><blockquote><p>不同引用类型详细分析</p></blockquote><ul><li><p><strong>强引用</strong></p><blockquote><p>什么是强引用</p></blockquote><p>最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似<code>0bject obj=new object()</code>这种引用关系。</p><p>「强引用」的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</p><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应(强)引用赋值为<code>null</code>,就是可以当做垃圾被收集了，当然具体回收时机还是要看「垃圾收集策略」。</p><p><strong>强引用是造成Java内存泄漏的主要原因之一。</strong></p><blockquote><p>强引用关联对象和垃圾回收的关系</p></blockquote><p>被「强引用」关联的对象<strong>不会被回收。</strong></p><blockquote><p>创建方式</p></blockquote><p>new 一个新对象就可以创建「强引用」。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li><p><strong>软引用</strong></p><blockquote><p>什么是软引用</p></blockquote><p>「软引用」用来描述一些还有用，但非必须的对象。</p><p><strong>在系统将要发生内存溢出之前，将会把「软引用」关联对象列入回收范围之中进行第二次回收</strong>。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</p><p>「软引用」通常用来实现内存敏感的缓存。比如: 高速缓存就有用到「软引用」。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><blockquote><p>软引用关联对象和垃圾回收的关系</p></blockquote><p>被「软引用」关联的对象只有<strong>在内存不够的情况下才会被回收。</strong></p><blockquote><p>创建方式</p></blockquote><p>使用 <code>SoftReference</code> 类来创建「软引用」。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">// 消除掉强引用，使obj只被软引用关联</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p><strong>弱引用</strong></p><blockquote><p>什么弱引用？</p></blockquote><p>弱引用也是描述那些非必需对象。</p><p>**被「弱引用」关联的对象只能生存到下一次垃圾收集之前。**当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被「弱引用」关联的对象。</p><p>由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有「弱引用」的对象。在这种情况下，「弱引用」对象可以存在较长的时间。</p><p>软引用、「弱引用」都非常适合来保存那些可有可无的缓存数据。<strong>当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</strong></p><blockquote><p>弱引用关联对象和垃圾回收的关系</p></blockquote><p>被「弱引用」关联的对象<strong>一定会被回收</strong>，也就是说它只能存活到下一次垃圾回收发生之前。</p><blockquote><p>创建方式</p></blockquote><p>使用 <code>WeakReference</code> 类来创建「弱引用」。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> wf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 消除掉强引用，使obj只被弱引用关联</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p><strong>虚引用</strong></p><blockquote><p>什么是虚引用？</p></blockquote><p>「虚引用」又称为幽灵引用或者幻影引用。一个对象是否有「虚引用」的存在，不会对其生存时间造成影响，也无法通过「虚引用」得到一个对象。</p><blockquote><p>虚引用关联对象和垃圾回收的关系</p></blockquote><p><strong>为一个对象设置「虚引用」的唯一目的是能在这个对象被回收时收到一个系统通知。</strong></p><blockquote><p>创建方式</p></blockquote><p>使用 <code>PhantomReference</code> 来创建「虚引用」。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> pf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 消除掉强引用，使obj只被虚引用关联</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ul><h2 id="何时回收" tabindex="-1"><a class="header-anchor" href="#何时回收" aria-hidden="true">#</a> 何时回收？</h2><h3 id="什么时候触发gc" tabindex="-1"><a class="header-anchor" href="#什么时候触发gc" aria-hidden="true">#</a> 什么时候触发GC？</h3><blockquote><p>什么时候触发<code>GC</code>，以及触发什么类型的<code>GC</code>？</p></blockquote><p>不同的垃圾收集器实现不一样，你还可以通过设置参数来影响<code>JVM</code>的决策。</p><ul><li><p>新生代会在<code>Eden</code>区用尽后才会触发<code>GC</code></p></li><li><p>老年代不能等<code>Old</code>区用尽才触发<code>GC</code></p><p>因为有的并发收集器在清理过程中，用户线程可以继续运行，这意味着程序仍然在创建对象、分配内存，这就需要老年代进行「空间分配担保」（新生代放不下的对象会被放入老年代）</p><p>如果老年代的回收速度比对象的创建速度慢，就会导致「分配担保失败」，这时<code>JVM</code>不得不触发<code>Full GC</code>，以此来获取更多的可用内存。</p><p><code>Full GC</code>的执行效率是比较差的，我们应该尽量的避免它的出现。</p></li></ul><blockquote><p>这里的介绍我们引入了<code>GC</code>的类型的概念，并且不同的<code>GC</code>的触发机制也不同，于是本章我们将「<code>GC</code>类型」的部分和与<code>GC</code>类型相关度比较高的「内存分配与回收策略」归档在本章。</p></blockquote><h3 id="各种gc" tabindex="-1"><a class="header-anchor" href="#各种gc" aria-hidden="true">#</a> 各种GC</h3><blockquote><p><code>JVM</code>在进行<code>GC</code>时，不是每次都是新生代、老年代、永久代一起回收的，大部分时候回收的都是指新生代。这里的<code>GC</code>的类型实际是针对回收堆内存区域的不同进行的抽象划分，具体的实现还是得看「如何回收」章节。本章先以简单的<code>GC</code>分类开头：</p></blockquote><p>针对<code>HotSpot VM</code>的实现，它里面的<code>GC</code>按照回收区域又分为两大种类型:</p><ul><li><p><strong>部分收集(<code>Partial GC</code>)</strong></p><p>不是完整收集整个Java堆的垃圾收集。其中又分为:</p><ul><li><p>新生代收集(<code>Young GC</code>):</p><p>只是新生代的垃圾收集。</p><p>一般来说就是<code>Minor GC</code></p></li><li><p>老年代收集(<code>Old GC</code>):</p><p>只是老年代的垃圾收集。</p><p>只有<code>CMS GC</code>会有单独收集老年代的行为。</p><p>很多时候<code>Major GC</code>会和<code>Full GC</code>混淆使用，需要具体分辨是老年代回收还是整堆回收。</p></li><li><p>混合收集(<code>Mixed GC</code>)</p><p>收集整个新生代以及部分老年代的垃圾收集。</p><p>目前，只有<code>G1 GC</code>会有这种行为</p></li></ul></li><li><p><strong>整堆收集(<code>Fu1l GC</code>)</strong></p><p>收集整个Java堆的垃圾收集。</p></li></ul><h4 id="minor-gc" tabindex="-1"><a class="header-anchor" href="#minor-gc" aria-hidden="true">#</a> Minor GC</h4><blockquote><p>什么是Minor GC？</p></blockquote><p>回收新生代，因为新生代对象存活时间很短，因此 <code>Minor GC</code> 会频繁执行，执行的速度一般也会比较快。</p><blockquote><p>触发条件</p></blockquote><p>当 <code>Eden</code> 区的空间耗尽了。这个时候 <code>JVM</code> 便会触发一次 <code>Minor GC</code> 来收集新生代的垃圾，存活下来的对象，则会被送到 <code>Survivor</code> 区。</p><blockquote><p>Minor GC 的过程</p></blockquote><p>新生代有两个 <code>Survivor</code> 区，我们分别用 from 和 to来指代。其中 to 指向的 <code>Survivor</code> 区是空的。</p><p>当发生 <code>Minor GC</code>时，<code>Eden</code> 区和 from 指向的 <code>Survivor</code> 区中的存活对象会被复制(「复制算法」)到 to 指向的 <code>Survivor</code> 区中，然后<strong>交换 from 和 to指针，以保证下一次 <code>Minor GC</code>时，to 指向的 <code>Survivor</code>区还是空的</strong>。</p><p><strong>对象在经过一次复制以后年龄要+1。</strong></p><blockquote><p>Survivor 区对象晋升到老年代对象</p></blockquote><p><code>JVM</code>会记录 <code>Survivor</code>区中的对象一共被来回复制了几次。<strong>如果一个对象被复制的次数为 15 (对应虚拟机参数 <code>-XX:+MaxTenuringThreshold</code>),那么该对象将被晋升为至老年代</strong>，(至于为什么是 15次，原因是 <code>HotSpot</code> 会在对象头的中的标记字段里记录年龄，分配到的空间只有4位，所以最多只能记录到15)。另外，<strong>如果单个 <code>Survivor</code> 区已经被占用了 50% (对应虚拟机参数: <code>-XX:TargetSurvivorRatio</code>)，那么较高复制次数的对象也会被晋升至老年代</strong></p><p><code>Survivor</code> 区对象晋升到老年代对象以后，会导致老年代的占用率升高。</p><p>在<code>Minor GC</code>过程中，<code>Survivor</code> 可能不足以容纳<code>Eden</code>和另一个<code>Survivor</code>中的存活对象。如果<code>Survivor</code>中的存活对象溢出，多余的对象将被移到老年代，这称为<strong>过早提升(Premature Promotion)</strong> 也可以被称为「分配担保机制」。</p><ul><li><blockquote><p>过早提升的问题</p></blockquote><p>这会导致老年代中短期存活对象的增长，可能会引发严重的性能问题。</p><p>在<code>Minor GC</code>过程中，如果老年代满了而无法容纳更多的对象，<code>Minor GC</code> 之后通常就会进行<code>Full GC</code>，这将导致遍历整个Java堆，这称为<strong>提升失败(Promotion Failure)</strong>。</p></li></ul><h4 id="full-gc" tabindex="-1"><a class="header-anchor" href="#full-gc" aria-hidden="true">#</a> Full GC</h4><blockquote><p>什么是Full GC？</p></blockquote><p><code>Full GC</code>就是收集整个堆，包括新生代，老年代，永久代（JDK1.8以前）。</p><p>老年代对象其存活时间长，因此 <code>Full GC</code> 很少执行，执行速度会比 <code>Minor GC</code> 慢很多。</p><blockquote><p>触发条件</p></blockquote><ul><li><p><strong>调用 <code>System.gc()</code></strong></p><p>只是建议虚拟机执行 <code>Full GC</code>，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p></li><li><p><strong>老年代空间不足</strong></p><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p><p>为了避免以上原因引起的 <code>Full GC</code>，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 <code>-Xmn</code> 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 <code>-XX:MaxTenuringThreshold</code> 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p></li><li><p><strong>空间分配担保失败</strong></p><p>使用复制算法的 <code>Minor GC</code> 需要老年代的内存空间作担保，如果担保失败会执行一次 <code>Full GC</code>。</p></li><li><p>JDK 1.7 及以前的永久代空间不足</p><p>在 JDK 1.7 及以前，<code>HotSpot</code> 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 <code>CMS GC</code> 的情况下也会执行 <code>Full GC</code>。如果经过 <code>Full GC</code> 仍然回收不了，那么虚拟机会抛出 <code>java.lang.OutOfMemoryError</code>。</p><p>为避免以上原因引起的 <code>Full GC</code>，可采用的方法为增大永久代空间或转为使用 <code>CMS GC</code>。</p></li><li><p><strong>Concurrent Mode Failure</strong></p><p>执行 <code>CMS GC</code> 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 <code>GC</code> 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 <code>Full GC</code>。</p></li></ul><h4 id="major-gc" tabindex="-1"><a class="header-anchor" href="#major-gc" aria-hidden="true">#</a> Major GC</h4><blockquote><p>什么是Major GC？</p></blockquote><p>还有一个名词是所谓的 <code>Major GC</code>，这个其实一般用的比较少，他是一个非常容易混淆的概念。</p><p><code>Full GC</code>定义是相对明确的。而<code>Major GC</code>是俗称。<code>Major GC</code>通常是跟<code>Full GC</code>是等价的，收集整个<code>GC</code>堆。但因为<code>HotSpot VM</code>发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“<code>Major GC</code>”的时候一定要问清楚他想要指的是上面的<code>Full GC</code>还是<code>Old GC</code>。</p><h3 id="内存分配与回收策略" tabindex="-1"><a class="header-anchor" href="#内存分配与回收策略" aria-hidden="true">#</a> 内存分配与回收策略</h3><ul><li><blockquote><p><strong>对象优先在Eden分配</strong></p></blockquote><p>大多数情况下，对象在新生代 <code>Eden</code> 区中分配。当 <code>Eden</code> 区没有足够空间进行分配时，虚拟机将发起一次 <code>Minor GC</code>。</p></li><li><blockquote><p><strong>大对象直接进入老年代</strong></p></blockquote><p>大对象是指需要大量连续内存空间的 Java 对象，如字符串或数据。</p><p>一个大对象能够存入 <code>Eden</code> 区的概率比较小，发生「分配担保」的概率比较大，而「分配担保」需要涉及大量的复制，就会造成效率低下。</p><p><code>JVM</code>提供了一个 <code>-XX:PretenureSizeThreshold</code> 参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在 <code>Eden</code> 区及两个 <code>Survivor</code> 区之间发生大量的内存复制（复制算法）。</p></li><li><blockquote><p><strong>长期存活的对象将进入老年代</strong></p></blockquote><p><code>JVM</code> 采用了「分代收集」的思想来管理内存，因此内存回收时需要能识别出哪些对象应该放在新生代，哪些对象应该放到老年代中。</p><p>因此<code>JVM</code> 给每个对象定义了一个对象年龄计数器。当新生代发生一次 <code>Minor GC</code> 后，存活下来的对象年龄 +1，当年龄超过一定值时，就将超过该值的所有对象转移到老年代中去。</p><p>使用 <code>-XXMaxTenuringThreshold</code> 设置新生代的最大年龄，只要超过该参数的新生代对象都会被转移到老年代中去。</p></li><li><blockquote><p><strong>动态对象年龄判定</strong></p></blockquote><p>如果当前新生代的 <code>Survivor</code> 中，相同年龄所有对象大小的总和大于 <code>Survivor</code> 空间的一半，年龄 &gt;= 该年龄的对象就可以直接进入老年代，无须等到 <code>MaxTenuringThreshold</code> 中要求的年龄。</p></li><li><blockquote><p><strong>空间分配担保</strong></p></blockquote><p>「空间分配担保」是为了确保在 <code>Minor GC</code> 之前老年代本身还有容纳新生代所有对象的剩余空间。</p><p>JDK 1.6 Update 24 之前的规则是这样的：</p><p>在发生 <code>Minor GC</code> 之前，虚拟机会先检查<strong>老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>， 如果这个条件成立，<code>Minor GC</code> 可以确保是安全的； 如果不成立，则虚拟机会查看 <code>HandlePromotionFailure</code> 值是否设置为允许担保失败， 如果是，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大于，将尝试进行一次 <code>Minor GC</code>，尽管这次 <code>Minor GC</code> 是有风险的； 如果小于，或者 <code>HandlePromotionFailure</code> 设置不允许冒险，那此时也要改为进行一次 <code>Full GC</code>。</p><p>JDK 1.6 Update 24 之后的规则变为：（<strong>主要还是看这里</strong>）</p><p>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小（老年代空间完全可以容纳新生代对象的晋升），就会进行 <code>Minor GC</code>，否则将进行 <code>Full GC</code>。</p><p><strong>通过清除老年代中的废弃数据来扩大老年代空闲空间，以便给新生代作担保。</strong></p><p><strong>这个过程就是分配担保。</strong></p></li></ul><h2 id="如何回收" tabindex="-1"><a class="header-anchor" href="#如何回收" aria-hidden="true">#</a> 如何回收？</h2><h3 id="垃圾收集算法" tabindex="-1"><a class="header-anchor" href="#垃圾收集算法" aria-hidden="true">#</a> 垃圾收集算法</h3><blockquote><p>本章将从分代收集理论开始，以此介绍垃圾收集相关算法，这些算法的执行过程都是<code>GC</code>的<strong>具体实现</strong>。</p></blockquote><h4 id="分代收集理论" tabindex="-1"><a class="header-anchor" href="#分代收集理论" aria-hidden="true">#</a> 分代收集理论</h4><blockquote><p>什么是分代收集理论？</p></blockquote><p><code>JVM</code>将「堆」划分成不同的代，不同的代中存放的对象特点不一样，<strong>针对不同的代使用不同的<code>GC</code>回收算法进行回收可以提升<code>GC</code>的效率。</strong></p><p>目前大多数<code>JVM</code>的「垃圾收集器」都遵循「分代收集」理论，「分代收集理论」建立在三个假说之上：</p><ul><li><p><strong>弱分代假说</strong></p><p><strong>绝大多数对象都是朝生夕死的。</strong></p><p>绝大多数时候，我们创建一个对象，只是为了进行一些业务计算，得到计算结果后这个对象也就没什么用了，即可以被回收了。 再例如：客户端要求返回一个列表数据，服务端从数据库查询后转换成<code>JSON</code>响应给前端后，这个列表的数据就可以被回收了。 诸如此类，都可以被称为「朝生夕死」的对象。</p></li><li><p><strong>强分代假说</strong></p><p><strong>熬过越多次<code>GC</code>的对象就越难以回收。</strong></p><p>这个假说完全是基于概率学统计来的，经历过多次<code>GC</code>都无法被回收的对象，可以假定它下次<code>GC</code>时仍然无法被回收，因此就没必要高频率的对其进行回收，将其挪到「老年代」，减少回收的频率，让<code>GC</code>去回收效益更高的「新生代」。</p></li><li><p><strong>跨代引用假说</strong></p><p><strong>「跨代引用」相对于同代引用是极少的。</strong></p><p>这是根据前两条假说逻辑推理得出的隐含推论：存在互相引用关系的两个对象，应该倾向于同时生存或者同时消亡的。</p><p>如果某个新生代对象存在「跨代引用」，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时「跨代引用」也随即被消除了。</p></li></ul><blockquote><p>解决跨代引用</p></blockquote><p>「跨代引用」虽然极少，但是它还是可能存在的。如果为了极少的「跨代引用」而去扫描整个老年代，那每次<code>GC</code>的开销就太大了，<code>GC</code>的暂停时间会变得难以接受。如果忽略「跨代引用」，会导致新生代的对象被错误的回收，导致程序错误。</p><p>一般的解决方式有以下几种：</p><ul><li><p><strong>Remembered Set</strong>(记忆集)</p><p><code>JVM</code>通过「记忆集」（Remembered Set）来解决。通过在新生代建立「记忆集」的数据结构，来避免回收新生代时把整个老年代也加进<code>GC Roots</code>的扫描范围，减少<code>GC</code>的开销。</p><blockquote><p>什么是记忆集？</p></blockquote><p>「记忆集」是一种由非收集区域指向收集区域的指针集合的抽象数据结构，也就是把「年轻代中被老年代引用的对象」给标记起来。「记忆集」可以有以下三种记录精度：</p><ul><li>字长精度：记录精确到一个机器字长，也就是处理器的寻址位数。</li><li>对象精度：精确到对象，对象的字段是否存在跨代引用指针。</li><li>卡精度：精确到一块内存区域，该区域内的对象是否存在跨代引用。</li></ul><blockquote><p>什么是卡表、卡页？</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221007204833069.png" alt="image-20221007204833069"></p><p>字长精度和对象精度太精细化了，需要花费大量的内存来维护「记忆集」，因此许多<code>JVM</code>都是采用的「卡精度」，也被称作“卡表”（Card Table）。</p><p><strong>「卡表」是「记忆集」的一种实现，也是目前最常用的一种形式，它定义了记忆集的记录精度、与对内存的映射关系等。</strong></p><p><strong><code>HotSpot</code>使用一个字节数组来实现「卡表」</strong>，它将堆空间划分成一系列2次幂大小的内存区域，这个内存区域就被称作「卡页」（Card Page）。</p><p>「卡页」的大小一般都是2的幂次方数，<code>HotSpot</code>采用2的9次幂，即512字节。</p><p><strong>字节数组的每一个元素都对应着一个「卡页」</strong>，如果某个「卡页」内的对象存在「跨代引用」，<code>JVM</code>就会将这个「卡页」标记为「Dirty」脏的，<strong><code>GC</code>时只需要扫描「脏页」对应的内存区域即可，避免扫描整个堆。</strong></p></li><li><p><strong>写屏障</strong></p><blockquote><p>请将这里的「写屏障」和并发编程中内存指令重排序的「写屏障」区分开，避免混淆。</p></blockquote><blockquote><p>卡表只是用来标记哪一块内存区域存在跨代引用的数据结构，<code>JVM</code>如何来维护卡表呢？</p></blockquote><p><code>HotSpot</code>是通过「写屏障」（Write Barrier）来维护「卡表」的，<code>JVM</code>拦截了「对象属性赋值」这个动作，类似于<code>AOP</code>的切面编程。</p><p><code>JVM</code>可以在对象属性赋值前后介入处理，赋值前的处理叫作「写前屏障」，赋值后的处理叫作「写后屏障」，伪代码如下：</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">setField</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//写前屏障</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>field <span class="token operator">=</span> o<span class="token punctuation">;</span>
	<span class="token function">after</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//写后屏障</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>什么时候将卡页变脏呢？</p></blockquote><p>开启「写屏障」后，<code>JVM</code>会为所有的赋值操作生成相应的指令。</p><p>一旦出现老年代对象的引用指向了年轻代的对象，<code>HotSpot</code>就会将对应的「卡表」元素置为脏的。</p><blockquote><p>伪共享</p></blockquote><p>除了「写屏障」本身的开销外，「卡表」在高并发场景下还面临着「伪共享」的问题。</p><ul><li><blockquote><p>现代计算机CPU缓存和内存的关系</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221009135521923.png" alt="image-20221009135521923"></p></li><li><blockquote><p>Cache Line</p></blockquote><p>现代CPU的缓存系统是以「缓存行」（<code>Cache Line</code>）为单位存储的，Intel 的 CPU「缓存行」的大小一般是64字节。</p><p>当一行 <code>Cache Line</code> 被从内存拷贝到 Cache 里，Cache 里会为这个 <code>Cache Line</code> 创建一个条目。这个 Cache 条目里既包含了拷贝的内存数据，即 <code>Cache Line</code>，又包含了这行数据在内存里的位置等元数据信息。</p><p><strong>当 CPU 访问某个变量时，首先会去看 CPU Cache 内是否有该变量，如果有则直接从中获取，否则就去主存里面获取该变量，然后把该变量所在内存区域的一个 <code>Cache Line</code> 大小的内存复制到 Cache 中。</strong></p><p>由于存放到 <code>Cache Line</code> 的是内存块而不是单个变量，所以可能会把多个连续的变量存放到一个 <code>Cache Line</code> 中。</p><p><strong>所以通常情况下访问连续存储的数据会比随机访问要快。</strong>(毕竟只需要读集中的内存，块数少)</p></li><li><blockquote><p>什么是伪共享？</p></blockquote><p><strong>多线程修改互相独立的变量时，如果这些变量在同一个缓存行中，就会导致彼此的缓存行无故失效</strong>，线程不得不频繁发起<code>load</code>指令重新加载数据，而导致性能降低。</p><ul><li><blockquote><p>具体的例子：</p></blockquote><p>一个<code>Cache Line</code>是64字节，每个「卡页」是512字节，64*512字节就是 32KB。</p><p>如果不同的线程更新的对象处在这 32KB 之内，就会导致更新「卡表」时正好写入同一个「缓存行」而影响性能。</p><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221009141106713.png" alt="image-20221009141106713"></p><p>如上图，变量 X 和 Y 同时被放到了 CPU 的 L1、L2 以及 L3，一个 Core 一次只能运行一条线程。</p><p>当 线程1 使用 Core 1 对变量 X 进行更新时，首先会修改 Core 1 的一级缓存变量 X 所在的「缓存行」，这时候在缓存一致性协议(<code>MESI</code>)下，Core 2 中变量 X 对应的「缓存行」失效。那么 线程2 在写入变量 Y 时就只能去二级缓存里查找，这就破坏了一级缓存。而一级缓存比二级缓存更快，这也说明了多个线程不可能同时去修改自己所使用的 CPU 中相同「缓存行」里面的变量。更坏的情况是，如果 CPU 只有一级缓存，则会导致频繁地访问主内存。</p><p>因为缓存与内存交换数据的单位就是「缓存行」，这就造成了造成多个变量被放入了一个「缓存行」中，为了保证缓存数据一致性，根据<code>MESI</code>协议，会使其他 Core 相同「缓存行」数据过期，如果多个线程同时去写入缓存行中不同的变量，虽然明面上不同线程读写不同的数据，但是由于数据在同一「缓存行」上，造成缓存频繁失效，就会无意中影响彼此的性能，这就是伪共享。由于从代码中很难看出是否会出现「伪共享」，有人将其描述成无声的性能杀手。</p></li></ul></li><li><blockquote><p>如何解决？</p></blockquote><p>为了避免这个问题，<code>HotSpot</code>支持只有当元素未被标记时，才将其置为脏的，这样会增加一次判断，但是可以避免「伪共享」的问题，设置-<code>XX:+UseCondCardMark</code>来开启这个判断。</p></li></ul></li></ul><h4 id="标记-清除算法" tabindex="-1"><a class="header-anchor" href="#标记-清除算法" aria-hidden="true">#</a> 标记-清除算法</h4><blockquote><p>什么是标记-清除算法？</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221009150717121.png" alt="image-20221009150717121"></p><p>当堆中的有效内存空间(available memory)被耗尽的时候，就会停止整个程序(也被称为stop the world)，进行「标记-清除算法」。</p><p><strong>「标记清除算法」分成两个过程</strong>：标记、清除：</p><ul><li><p><strong>标记</strong></p><p>遍历所有的 <code>GC Roots</code>，然后将所有 <code>GC Roots</code> 可达的对象「标记」为存活对象（一般是再对象的Header中记录为可达对象）。</p></li><li><p><strong>清除</strong></p><p>遍历堆中所有的对象，将没有标记的对象全部「清除」掉。与此同时，「清除」那些被标记过的对象的标记（对象Header中没有标记为可达对象），以便下次的垃圾回收。</p><p>同时「清除」不是真的置空，而是把需要清除的对象地址保存在「空闲地址列表」中。下次有新对象需要加载时，判断垃圾对象的位置空间是否够，如果够，就存放。</p><ul><li><blockquote><p>空闲列表</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221010194831574.png" alt="image-20221010194831574"></p><p>虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为：空闲列表(Free List)。</p></li></ul></li></ul><blockquote><p>缺点</p></blockquote><ul><li><p>效率问题（<strong>执行效率不稳定</strong>）</p><p>标记和清除两个过程的效率都不高。标记和清除的时间消耗随着Java堆中的对象不断增加而增加。</p><p>在进行<code>GC</code>的时候要停止整个应用程序，导致用户体验差。</p></li><li><p>空间问题（<strong>内存碎片</strong>）</p><p>标记清除之后会产生大量不连续的内存碎片，碎片太多可能导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p></li></ul><h4 id="复制算法" tabindex="-1"><a class="header-anchor" href="#复制算法" aria-hidden="true">#</a> 复制算法</h4><blockquote><p>什么是复制算法？</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221009150736780.png" alt="image-20221009150736780"></p><p>为了解决标记-清除算法产生的内存碎片问题，「复制算法」被提出。</p><p>在新生代，对常规应用的<code>GC</code>，一次通常可以回收70%~99%的内存空间，回收性价比很高。现在的商业<code>JVM</code>都是用复制算法来回收新生代的。</p><ul><li><blockquote><p>解决空间问题（复制操作）</p></blockquote><p>为了解决空间利用率问题，「复制算法」将内存分为三块： <code>Eden</code>、<code>From Survivor</code>、<code>To Survivor</code>，比例是 8:1:1。</p><p>每次使用 <code>Eden</code> 和其中一块 <code>Survivor</code>。回收时，将 <code>Eden</code> 和 <code>Survivor</code> 中还存活的对象一次性「复制」到另外一块 <code>Survivor</code> 空间上，最后清理掉 <code>Eden</code> 和刚才使用的 <code>Survivor</code> 空间。<strong>这样只有 10% 的内存被浪费。</strong></p><p>大部分对象都会再第一次<code>GC</code>时被回收，需要被「复制」的往往是极少数对象。但是我们无法保证每次回收都只有不多于 10% 的对象存活，当 <code>Survivor</code> 空间不够，需要依赖其他内存（指老年代）进行「分配担保」。</p><ul><li><blockquote><p>分配担保</p></blockquote><p>「分配担保」可以说是复制操作的保险了。</p><p>为对象分配内存空间时，如果 <code>Eden+Survivor</code> 中空闲区域无法装下该对象，会触发 <code>MinorGC</code> 进行垃圾收集。但如果 <code>Minor GC</code> 过后依然有超过 10% 的对象存活（一个<code>Survivor</code>区装不下），这样存活的对象直接通过「分配担保机制」进入老年代，然后再将新对象存入 <code>Eden</code> 区。</p></li></ul></li></ul><blockquote><p>优点</p></blockquote><ul><li>没有标记和清除过程，实现简单，运行高效（复制算法的高效性是建立在存活对象少、垃圾对象多的前提下）</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li><li>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大（复制较少对象，<code>STW</code>更短）。</li></ul><blockquote><p>缺点</p></blockquote><ul><li>需要两倍的内存空间。（对于存活对象来说）</li><li>对于<code>G1</code>这种分拆成为大量<code>region</code>的<code>GC</code>，复制而不是移动，意味着<code>GC</code>需要维护<code>region</code>之间对象引用关系，不管是内存占用或者时间开销也不小。</li></ul><h4 id="标记-整理算法" tabindex="-1"><a class="header-anchor" href="#标记-整理算法" aria-hidden="true">#</a> 标记-整理算法</h4><blockquote><p>什么是标记-整理算法？</p></blockquote><p>复制算法除了在对象大量存活时需要进行较多的复制操作外，还需要额外的内存空间老年代进行分配担保。其次复制算法的高效性是建立在存活对象少、垃圾对象多的前提下。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。</p><p>所以在老年代中一般不采用复制算法。</p><p>基于老年代垃圾回收的特性，<code>JVM</code>设计者在标记-清除算法的基础上改进并发明了「标记-整理算法」。</p><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221009160635443.png" alt="image-20221009160635443"></p><ul><li><blockquote><p>整理操作（压缩操作）</p></blockquote><p>被标记存活的对象会被移动，将所有存活对象「压缩」到内存的一端，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。当我们需要给新对象分配内存时，<code>JVM</code>只需要持有一个内存的起始地址即可，这比维护一个空闲列表少了很多开销。</p></li></ul><p>「标记-整理算法」的最终效果等同于标记-清理算法执行完成后，再进行一次内存碎片整理。但是这两个算法是有本质区别的，标记-清除算法是一种非移动式的算法，「标记-整理算法」是移动式的。</p><blockquote><p>优点</p></blockquote><ul><li>消除了「标记-清除算法」当中，内存区域分散的缺点，我们需要给新对象分配内存时，<code>JVM</code>只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><blockquote><p>缺点</p></blockquote><ul><li>从效率上来说，「标记-整理算法」要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。移动过程中，需要全程暂停用户应用程序（<code>STW</code>）</li></ul><blockquote><p>三种算法比较</p></blockquote><table><thead><tr><th>指标</th><th>标记-清除(Mark-Sweep)</th><th>复制算法（Copying）</th><th>标记-整理（Mark-Compact）</th></tr></thead><tbody><tr><td>速度</td><td>中等</td><td>最快</td><td>最慢</td></tr><tr><td>空间开销</td><td>少(但会堆积碎片)</td><td>通常需要活对象的2倍大小(不堆积碎片)</td><td>少(不堆积碎片)</td></tr><tr><td>移动对象</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><h3 id="分代收集算法" tabindex="-1"><a class="header-anchor" href="#分代收集算法" aria-hidden="true">#</a> 分代收集算法</h3><blockquote><p>根据「分代收集理论」，几乎所有的<code>JVM</code>都会采用「分代收集算法」——根据对象存活周期将内存划分为几块，不同快采用适当的收集算法。</p></blockquote><p>一般把Java堆分成新生代和老年代：</p><ul><li><p>新生代</p><blockquote><p>特点</p></blockquote><p>区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p><blockquote><p>使用的垃圾回收算法</p></blockquote><p>复制算法</p><p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于新生代的回收。而复制算法内存利用率不高的问题，通过<code>hotspot</code>中的两个<code>survivor</code>的设计得到缓解。</p></li><li><p>老年代</p><blockquote><p>特点</p></blockquote><p>区域较大，对象生命周期长、存活率高，回收不及新生代频繁。</p><blockquote><p>使用的垃圾回收算法</p></blockquote><p>标记-清除 或者 标记-整理 算法</p><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p><ul><li>Mark（标记）阶段的开销与存活对象的数量成正比。</li><li>Sweep（清除）阶段的开销与所管理区域的大小成正相关。</li><li>Compact（整理）阶段的开销与存活对象的数据成正比。</li></ul></li></ul><h3 id="增量收集算法" tabindex="-1"><a class="header-anchor" href="#增量收集算法" aria-hidden="true">#</a> 增量收集算法</h3><blockquote><p>什么是增量收集算法？</p></blockquote><p>在垃圾回收过程中，应用软件将进入<code>STW</code>的状态。在<code>STW</code>状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。</p><p>为了解决这个问题，<strong>「增量收集算法」让垃圾收集线程和应用程序线程交替执行。每次垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程，依次反复，直到垃圾收集完成。</strong></p><p>「增量收集算法」通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</p><blockquote><p>缺点</p></blockquote><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码, 所以能减少系统的停顿时间。<strong>但是因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</strong></p><h1 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h1><p>本篇文章我们介绍了垃圾回收机制的相关概念，和这个知识点关联比较紧密的是垃圾收集器，关于垃圾收集器的内容我将专门分出一篇博客来介绍。</p><p>本文参考：</p><ul><li><p>https://blog.csdn.net/qq_32099833/article/details/109253339</p></li><li><p>https://javap.blog.csdn.net/article/details/112856854</p></li><li><p>http://www.cyc2018.xyz/Java/</p></li><li><p>https://javaguide.cn/java/jvm/jvm-garbage-collection.html</p></li><li><p>https://juejin.cn/post/7019475740970188837</p></li><li><p>https://juejin.cn/post/7000608853968551943</p></li><li><p>https://www.cnblogs.com/wupeixuan/p/12198189.html</p></li></ul><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></footer><!----><!--[--><!--]--><!----></main><ul class="catalog" style="top:0px;"><li class="level-2 toc-link-什么是垃圾回收机制">什么是垃圾回收机制？</li><li class="level-2 toc-link-java-堆的内存结构">Java 堆的内存结构</li><li class="level-2 toc-link-哪些内存需要回收">哪些内存需要回收？</li><li class="level-3 toc-link-判断对象是否可以被回收">判断对象是否可以被回收</li><li class="level-3 toc-link-引用类型">引用类型</li><li class="level-2 toc-link-何时回收">何时回收？</li><li class="level-3 toc-link-什么时候触发gc">什么时候触发GC？</li><li class="level-3 toc-link-各种gc">各种GC</li><li class="level-3 toc-link-内存分配与回收策略">内存分配与回收策略</li><li class="level-2 toc-link-如何回收">如何回收？</li><li class="level-3 toc-link-垃圾收集算法">垃圾收集算法</li><li class="level-3 toc-link-分代收集算法">分代收集算法</li><li class="level-3 toc-link-增量收集算法">增量收集算法</li></ul></div><!--]--></div><div class="search-page" role="search"><span class="search-close"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" width="28" height="28" fill="currentColor"><path d="M224 416c-8.188 0-16.38-3.125-22.62-9.375l-192-192c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L224 338.8l169.4-169.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-192 192C240.4 412.9 232.2 416 224 416z"></path></svg></span><div class="gungnir-search-box"><input placeholder="$ grep ..." autocomplete="off" spellcheck="false" value><!----></div></div><div class="menu-btn-container"><div class="menu-btn-wrapper"><div class="menu-btn"><div style="" class="menu-btn-icon"><span></span><span></span><span></span></div><div style="display:none;" class="menu-text">0</div><svg class="menu-progress"><circle class="menu-border" cx="50%" cy="50%" r="48%" style="stroke-dasharray:0% 314.15926%;"></circle></svg></div><div class="menu-btn-child-wrapper"><div class="toggle-dark-button menu-btn-child" title="toggle dark mode"><svg class="ov-icon" style="font-size:1.2em;display:none;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"/></svg><svg class="ov-icon" style="font-size:1.2em;display:none;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 00283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"/></svg><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M224 96l16-32 32-16-32-16-16-32-16 32-32 16 32 16 16 32zM80 160l26.66-53.33L160 80l-53.34-26.67L80 0 53.34 53.33 0 80l53.34 26.67L80 160zm352 128l-26.66 53.33L352 368l53.34 26.67L432 448l26.66-53.33L512 368l-53.34-26.67L432 288zm70.62-193.77L417.77 9.38C411.53 3.12 403.34 0 395.15 0c-8.19 0-16.38 3.12-22.63 9.38L9.38 372.52c-12.5 12.5-12.5 32.76 0 45.25l84.85 84.85c6.25 6.25 14.44 9.37 22.62 9.37 8.19 0 16.38-3.12 22.63-9.37l363.14-363.15c12.5-12.48 12.5-32.75 0-45.24zM359.45 203.46l-50.91-50.91 86.6-86.6 50.91 50.91-86.6 86.6z"/></svg></div><div class="menu-btn-child"><svg class="ov-icon" style="font-size:1.7999999999999998em;" aria-hidden="true" width="28.799999999999997" height="28.799999999999997" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"/></svg></div><div class="menu-btn-child"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M240.971 130.524l194.343 194.343c9.373 9.373 9.373 24.569 0 33.941l-22.667 22.667c-9.357 9.357-24.522 9.375-33.901.04L224 227.495 69.255 381.516c-9.379 9.335-24.544 9.317-33.901-.04l-22.667-22.667c-9.373-9.373-9.373-24.569 0-33.941L207.03 130.525c9.372-9.373 24.568-9.373 33.941-.001z"/></svg></div><div class="menu-btn-child menu-toc-btn"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M48 48a48 48 0 1048 48 48 48 0 00-48-48zm0 160a48 48 0 1048 48 48 48 0 00-48-48zm0 160a48 48 0 1048 48 48 48 0 00-48-48zm448 16H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16v-32a16 16 0 00-16-16zm0-320H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16V80a16 16 0 00-16-16zm0 160H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16v-32a16 16 0 00-16-16z"/></svg></div><div class="toggle-sidebar-button menu-btn-child menu-btn-sidebar" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-1.6 -1.6 19.2 19.2" fill="currentColor"><path d="M14 2a1 1 0 011 1v10a1 1 0 01-1 1H2a1 1 0 01-1-1V3a1 1 0 011-1h12zM2 1a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V3a2 2 0 00-2-2H2z"/><path d="M3 4a1 1 0 011-1h2a1 1 0 011 1v8a1 1 0 01-1 1H4a1 1 0 01-1-1V4z"/></svg></div></div></div></div><footer class="footer"><span>
                &copy; pixel-revolve 2021-2022
                <br>
                Powered by <a href="https://vuepress.vuejs.org" target="_blank">VuePress</a> &
                <a href="https://github.com/Renovamen/vuepress-theme-gungnir" target="_blank">Gungnir</a>
                </span></footer></div><!--]--></div>
    <script type="module" src="/assets/app.9fd9aa02.js" defer></script>
  </body>
</html>
