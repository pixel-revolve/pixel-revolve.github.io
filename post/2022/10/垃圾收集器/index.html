<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.38">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/img/logo-broccoli.png"><title>从零开始的JVM学习--垃圾收集器 | pixel-revolve</title><meta name="description" content="爱编程，爱生活">
    <link rel="modulepreload" href="/assets/app.9fd9aa02.js"><link rel="modulepreload" href="/assets/index.html.cc3143b4.js"><link rel="modulepreload" href="/assets/index.html.a01a5ede.js">
    <link rel="stylesheet" href="/assets/style.2781e754.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container no-sidebar"><!--[--><header class="navbar invert"><span><a href="/" class=""><span class="site-name">$ cd /home/</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="Home"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/></svg></span><span>Home</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/tags/" class="" aria-label="Tags"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M17.707 9.293a1 1 0 010 1.414l-7 7a1 1 0 01-1.414 0l-7-7A.997.997 0 012 10V5a3 3 0 013-3h5c.256 0 .512.098.707.293l7 7zM5 6a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/></svg></span><span>Tags</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/links/" class="" aria-label="Links"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z" clip-rule="evenodd"/></svg></span><span>Links</span><!--[--><!--]--></a></div><!--]--><div class="navbar-item"><a style="cursor:pointer;"><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 2c4.968 0 9 4.032 9 9s-4.032 9-9 9-9-4.032-9-9 4.032-9 9-9zm0 16c3.867 0 7-3.133 7-7 0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7zm8.485.071l2.829 2.828-1.415 1.415-2.828-2.829 1.414-1.414z"/></svg></span><span>Search</span></a></div></nav><!--[--><!--]--><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="Home"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/></svg></span><span>Home</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/tags/" class="" aria-label="Tags"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M17.707 9.293a1 1 0 010 1.414l-7 7a1 1 0 01-1.414 0l-7-7A.997.997 0 012 10V5a3 3 0 013-3h5c.256 0 .512.098.707.293l7 7zM5 6a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd"/></svg></span><span>Tags</span><!--[--><!--]--></a></div><div class="navbar-item"><a href="/links/" class="" aria-label="Links"><!--[--><!--]--><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z" clip-rule="evenodd"/></svg></span><span>Links</span><!--[--><!--]--></a></div><!--]--><div class="navbar-item"><a style="cursor:pointer;"><span class="nav-icon"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 2c4.968 0 9 4.032 9 9s-4.032 9-9 9-9-4.032-9-9 4.032-9 9-9zm0 16c3.867 0 7-3.133 7-7 0-3.868-3.133-7-7-7-3.868 0-7 3.132-7 7 0 3.867 3.132 7 7 7zm8.485.071l2.829 2.828-1.415 1.415-2.828-2.829 1.414-1.414z"/></svg></span><span>Search</span></a></div></nav><!--[--><!--]--><!----><!--[--><!--]--></aside><!--]--><div class="page-content"><!--[--><div class="show-catalog post-wrapper"><div class="article-header use-image post-header" style="background-image:url(/img/blog_cover/2022/10/从零开始的JVM学习--垃圾收集器.png);"><div class="article-header-mask" style="background:rgba(40, 57, 101, .4);"></div><div class="article-header-content"><div class="article-tags"><!--[--><span class="article-tag">JVM</span><!--]--></div><h1 class="article-title">从零开始的JVM学习--垃圾收集器</h1><p class="article-subtitle">学了垃圾回收机制后还要了解执行者</p><div class="article-icons"><div class="article-icon"><svg class="ov-icon" style="font-size:1.08em;" aria-hidden="true" width="17.28" height="17.28" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M313.6 304c-28.7 0-42.5 16-89.6 16-47.1 0-60.8-16-89.6-16C60.2 304 0 364.2 0 438.4V464c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48v-25.6c0-74.2-60.2-134.4-134.4-134.4zM400 464H48v-25.6c0-47.6 38.8-86.4 86.4-86.4 14.6 0 38.3 16 89.6 16 51.7 0 74.9-16 89.6-16 47.6 0 86.4 38.8 86.4 86.4V464zM224 288c79.5 0 144-64.5 144-144S303.5 0 224 0 80 64.5 80 144s64.5 144 144 144zm0-240c52.9 0 96 43.1 96 96s-43.1 96-96 96-96-43.1-96-96 43.1-96 96-96z"/></svg><span>pixel-revolve</span></div><div class="article-icon"><svg class="ov-icon" style="font-size:1.08em;" aria-hidden="true" width="17.28" height="17.28" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M400 64h-48V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H160V12c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v52H48C21.5 64 0 85.5 0 112v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48zm-6 400H54c-3.3 0-6-2.7-6-6V160h352v298c0 3.3-2.7 6-6 6z"/></svg><span>2022-10-12</span></div><div class="article-icon"><svg class="ov-icon" style="font-size:1.08em;" aria-hidden="true" width="17.28" height="17.28" viewBox="0 0 24 24" fill="currentColor"><path fill="none" d="M0 0h24v24H0z"/><path d="M17.618 5.968l1.453-1.453 1.414 1.414-1.453 1.453a9 9 0 11-1.414-1.414zM12 20a7 7 0 100-14 7 7 0 000 14zM11 8h2v6h-2V8zM8 1h8v2H8V1z"/></svg><span>18 min</span></div></div></div><!----></div><main class="page post-content"><!--[--><!--]--><div class="theme-gungnir-content"><!--[--><h1 id="简单介绍" tabindex="-1"><a class="header-anchor" href="#简单介绍" aria-hidden="true">#</a> 简单介绍</h1><h2 id="什么是垃圾收集器" tabindex="-1"><a class="header-anchor" href="#什么是垃圾收集器" aria-hidden="true">#</a> 什么是垃圾收集器</h2><blockquote><p>什么是垃圾收集器？</p></blockquote><p>如果说垃圾收集算法是内存回收的方法论，那么「垃圾收集器」就是<strong>内存回收的具体实现</strong>或者说是<strong>内存回收的执行者</strong>。</p><p>「垃圾收集器」本身并没有优劣之分，我们需要做的是根据具体场景选择<strong>合适</strong>的「垃圾收集器」。</p><blockquote><p>于是<strong>本篇重点</strong>在介绍各种「垃圾收集器」的<strong>特点</strong>，并且介绍它们<strong>适合的应用场景</strong>和原因。</p></blockquote><h2 id="安全点-safepoint" tabindex="-1"><a class="header-anchor" href="#安全点-safepoint" aria-hidden="true">#</a> 安全点（SafePoint）</h2><blockquote><p>什么是SafePoint？</p></blockquote><p><strong>程序执行时并非在所有地方都能停顿下来开始<code>GC</code>，只有在到达<code>SafePoint</code>时才能暂停</strong>。</p><p><code>SafePoint</code>的选定既不能太少以至于让<code>GC</code>等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。</p><p>基本上是以程序「是否具有让程序长时间执行的特征」为标准进行选定的。</p><p>「长时间执行」的最明显特征就是「指令序列复用」（例如方法调用、循环跳转、异常跳转等）。所以具有这些功能的指令才会产生<code>Safepoint</code>。</p><p><code>SafePoint</code>的目的并不是让其他线程停下，而是<strong>找到一个稳定的执行状态</strong>。<strong>在这个执行状态下，<code>JVM</code>的堆栈不会发生变化</strong>。这样垃圾回收器便能够“安全”地执行「可达性分析」。只要不离开这个<code>SafePoint</code>，<code>JVM</code>便能够在垃圾回收的同时，继续运行这段本地代码。</p><blockquote><p>如何在 SafePoint 停顿？</p></blockquote><p>对于<code>SafePoint</code>，另一个需要考虑的问题就是如何在<code>GC</code>发生时让所有线程（这里不包括执行<code>JNI</code>调用的线程）都“跑”到最近的<code>SafePoint</code>上再停顿下来。</p><p>两种解决方案：</p><ul><li><p><strong>抢先式中断</strong>（Preemptive Suspension）</p><p>「抢先式中断」不需要线程的执行代码主动去配合，在<code>GC</code>发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在<code>SafePoint</code>上，就恢复线程，让它“跑”到<code>SafePoint</code>上。</p><p>现在<strong>几乎没有虚拟机采用这种方式</strong>来暂停线程从而响应<code>GC</code>事件。</p></li><li><p><strong>主动式中断</strong>（Voluntary Suspension）</p><p>「主动式中断」的思想是当<code>GC</code>需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志。各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。</p><p>「轮询标志的地方」和<code>SafePoint</code>是重合的，另外再加上创建对象需要分配内存的地方。</p></li></ul><h1 id="垃圾收集器" tabindex="-1"><a class="header-anchor" href="#垃圾收集器" aria-hidden="true">#</a> 垃圾收集器</h1><blockquote><p>本章会提及几个算法包括但不限于「复制算法」，「标记-整理算法」，「标记清除算法」。</p><p>这些内容都在我的博客：<a href="https://juejin.cn/post/7153141395958530056" target="_blank" rel="noopener noreferrer">从零开始的JVM学习--GC</a>中介绍。</p></blockquote><h2 id="新生代收集器" tabindex="-1"><a class="header-anchor" href="#新生代收集器" aria-hidden="true">#</a> 新生代收集器</h2><h3 id="serial" tabindex="-1"><a class="header-anchor" href="#serial" aria-hidden="true">#</a> Serial</h3><blockquote><p>什么是Serial？</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221012135640543.png" alt="image-20221012135640543"></p><p><code>Serial</code>（串行）是一个单线程的垃圾收集器，只开启一条 <code>GC</code> 线程进行垃圾回收，并且在垃圾收集过程中停止一切用户线程（ <code>Stop The World</code>）。</p><p>由于 <code>Serial</code> 收集器只使用一条 <code>GC</code> 线程，避免了线程切换的开销，从而简单高效。</p><p><strong><code>Serial</code>在新生代使用「复制算法」。</strong></p><blockquote><p>适用场景</p></blockquote><p><code>Serial</code> 垃圾收集器<strong>适合<code>Client</code>场景下</strong>使用。</p><p><code>Serial</code>简单而高效，<code>Serial</code> 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。</p><p>一般「客户端」应用所需内存较小，不会创建太多对象，而且堆内存不大，因此垃圾收集器回收时间短，即使在这段时间停止一切用户线程，也不会感觉明显卡顿。</p><p><code>Serial</code>收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p><h3 id="parnew" tabindex="-1"><a class="header-anchor" href="#parnew" aria-hidden="true">#</a> ParNew</h3><blockquote><p>什么是ParNew？</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221012140004765.png" alt="image-20221012140004765"></p><p><code>ParNew</code> 是 <code>Serial</code> 的多线程版本。由多条 <code>GC</code> 线程并行地进行垃圾清理。但清理过程依然需要 <code>Stop The World</code>。</p><p><code>ParNew</code> 追求「<strong>低停顿时间</strong>」，与 <code>Serial</code> 唯一区别就是使用了多线程进行垃圾收集，在多 CPU 环境下性能比 <code>Serial</code> 会有一定程度的提升；但<strong>线程切换需要额外的开销</strong>，因此在单 CPU 环境中表现不如 <code>Serial</code>。</p><p><strong><code>ParNew</code>在新生代使用「复制算法」。</strong></p><blockquote><p>适用场景</p></blockquote><p><code>ParNew</code>是 <strong><code>Server</code> 场景下默认的新生代收集器。</strong>（停顿时间越短就越适合与用户交互的程序，良好的相应速度能提升用户体验）</p><p>除了<code>Serial</code>收集器，只有<code>ParNew</code>可以和<code>CMS</code>收集器配合使用。</p><p>根据上面的介绍我们知道<code>ParNew</code>适合<strong>多核CPU环境</strong>。并且<code>ParNew</code> 追求低停顿，因此<code>ParNew</code>适合<strong>交互式应用</strong>。</p><h3 id="parallel-scavenge" tabindex="-1"><a class="header-anchor" href="#parallel-scavenge" aria-hidden="true">#</a> Parallel Scavenge</h3><blockquote><p>什么是Parallel Scavenge？</p></blockquote><p><code>Parallel Scavenge</code> 和 <code>ParNew</code> 一样，都是多线程、新生代垃圾收集器。但是这两者的目的是不一样的：</p><ul><li><p><code>Parallel Scavenge</code> 追求 「CPU 吞吐量」</p><p>「高吞吐量」则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p></li><li><p><code>ParNew </code> 追求「降低用户停顿时间」</p><p>「降低用户停顿时间」是以牺牲吞吐量和新生代空间来换取的。（新生代空间变小，垃圾回收变得频繁，导致吞吐量下降）</p></li></ul><blockquote><p>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)</p></blockquote><blockquote><p>提高吞吐量的利弊</p></blockquote><p>追求「高吞吐量」，可以<strong>减少 <code>GC</code> 执行实际工作的时间</strong>，高效率的利用CPU的时间</p><p>然而，<strong>仅仅偶尔运行 <code>GC</code> 意味着每当 <code>GC</code> 运行时将有许多工作要做，因为在此期间积累在堆中的对象数量很高。</strong></p><p>单个 <code>GC</code> 需要花更多的时间来完成，从而导致更高的「暂停时间」。<strong>而考虑到「低暂停时间」，最好频繁运行 <code>GC</code> 以便更快速完成，反过来又导致「吞吐量」下降。</strong></p><blockquote><p>停顿时间和吞吐量相关参数</p></blockquote><ul><li><code>-XX:GCTimeRadio</code> 设置垃圾回收时间占总 CPU 时间的百分比。</li><li><code>-XX:MaxGCPauseMillis</code> 设置垃圾处理过程最久停顿时间。</li><li><code>-XX:+UseAdaptiveSizePolicy</code> 开启自适应策略。我们只要设置好堆的大小和 <code>MaxGCPauseMillis</code> 或 <code>GCTimeRadio</code>，收集器会自动调整新生代的大小、<code>Eden</code> 和 <code>Survivor</code> 的比例、对象进入老年代的年龄，以最大程度上接近我们设置的 <code>MaxGCPauseMillis</code> 或 <code>GCTimeRadio</code>。</li></ul><blockquote><p>适用场景</p></blockquote><p><code>Parallel Scavenge</code> 追求 <strong>CPU 吞吐量</strong>，能够在较短时间内完成指定任务，因此<strong>适合没有交互的后台计算</strong>。</p><h2 id="老年代收集器" tabindex="-1"><a class="header-anchor" href="#老年代收集器" aria-hidden="true">#</a> 老年代收集器</h2><h3 id="serial-old" tabindex="-1"><a class="header-anchor" href="#serial-old" aria-hidden="true">#</a> Serial Old</h3><blockquote><p>什么是Serial Old?</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221012140029292.png" alt="image-20221012140029292"></p><p><code>Serial Old</code> 收集器是 <code>Serial</code> 的老年代版本，都是<strong>单线程收集器</strong>，只启用一条 <code>GC</code> 线程。</p><p><code>Serial Old</code> 工作在老年代，使用「标记-整理算法」，<code>Serial</code> 工作在新生代，使用「复制算法」。</p><blockquote><p>适用场景</p></blockquote><p>上一个标题已经介绍了<code>Serial Old</code> 不过是<code>Serial</code>的老年代版本，并且在<code>Client</code>场景下一般是两个一起搭配适用的。</p><p>所以<code>Serial Old</code>是<strong>适合<code>Client</code>场景</strong>的。</p><p>如果是在<code>Server</code>场景下也有两个应用场景：</p><ul><li>在 JDK 1.5 以及之前版本（<code>Parallel Old</code> 诞生以前）中与 <code>Parallel Scavenge</code> 收集器搭配使用。</li><li>作为 <code>CMS</code> 收集器的后备预案，在并发收集发生 <code>Concurrent Mode Failure</code> 时使用。</li></ul><h3 id="parallel-old" tabindex="-1"><a class="header-anchor" href="#parallel-old" aria-hidden="true">#</a> Parallel Old</h3><blockquote><p>什么是Parallel Old？</p></blockquote><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221012141255739.png" alt="image-20221012141255739"></p><p><code>Parallel Old</code> 收集器是 <code>Parallel Scavenge</code> 的老年代版本，都追求 CPU 吞吐量。</p><blockquote><p>适用场景</p></blockquote><p>在<strong>注重吞吐量以及 CPU 资源敏感的场景下</strong>，可以优先考虑 <code>Parallel Scavenge</code> + <code>Parallel Old</code>。</p><h3 id="cms" tabindex="-1"><a class="header-anchor" href="#cms" aria-hidden="true">#</a> CMS</h3><blockquote><p>什么是CMS？</p></blockquote><p><code>CMS</code>（Concurrent Mark Sweep，并发标记清除）收集器是以获取最短回收停顿时间为目标的收集器（追求低停顿）</p><p><code>CMS</code>在垃圾收集时使得<strong>用户线程和 <code>GC</code> 线程并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。</strong></p><p><code>Mark Sweep</code>指的就是「标记-清除算法」，所以可以清楚<code>CMS</code>是基于「标记-清除算法」的。</p><blockquote><p>CMS 的执行流程</p></blockquote><p>下图标成蓝色的是<code>CMS</code>线程：</p><p><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221012142542923.png" alt="image-20221012142542923"></p><ul><li><p><strong>初始标记</strong>（CMS initial mark）</p><p><code>Stop The World</code>，仅使用一条初始标记线程对所有与 <code>GC Roots</code> 直接关联的对象进行标记。</p></li><li><p><strong>并发标记</strong>（CMS concurrent mark）</p><p>不需要停顿，使用<strong>多条</strong>标记线程，与用户线程并发执行。此过程进行可达性分析，标记出所有废弃对象。速度很慢。</p></li><li><p><strong>重新标记</strong>（CMS remark）</p><p><code>Stop The World</code>，使用<strong>多条标记线程并发执行</strong>，将刚才并发标记过程中新出现的废弃对象标记出来。</p></li><li><p><strong>并发清除</strong>（CMS concurrent sweep）</p><p>不需要停顿，只使用<strong>一条</strong> <code>GC</code> 线程，与用户线程并发执行，清除刚才标记的对象。这个过程非常耗时。</p></li></ul><blockquote><p>为什么说 CMS 可以做到与应用程序线程并发执行？</p></blockquote><p>根本原因在于<strong>采用基于「标记-清除」的算法并对算法过程进行了细粒度的分解</strong>。以流水线方式拆分了收集周期，将耗时长的操作单元保持与应用线程并发执行。</p><p><strong>并发标记与并发清除过程耗时最长，而这个过程中收集器线程可以与用户线程一起工作</strong>。因此总体上说，<code>CMS</code> 收集器的内存回收过程是与用户线程<strong>一起并发执行</strong>的。</p><blockquote><p>CMS 的优点</p></blockquote><p>并发收集，低停顿。</p><blockquote><p>CMS 的缺点</p></blockquote><ul><li><p>吞吐量低</p><p>「低停顿时间」是以牺牲「吞吐量」为代价的，导致 CPU 利用率不够高。</p></li><li><p>无法处理浮动垃圾</p><p>可能出现 <code>Concurrent Mode Failure</code>。「浮动垃圾」是指「并发清除」阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 <code>GC</code> 时才能进行回收。由于「浮动垃圾」的存在，因此需要预留出一部分内存，意味着 <code>CMS</code> 收集不能像其它收集器那样等待老年代快满的时候再回收。</p><p>如果预留的内存不够存放「浮动垃圾」，就会出现 <code>Concurrent Mode Failure</code>，这时虚拟机将临时启用 <code>Serial Old</code> 来替代 <code>CMS</code>。</p></li><li><p>导致频繁 <code>Full GC</code></p><p>「标记 - 清除算法」导致的内存碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 <code>Full GC</code>。</p></li></ul><blockquote><p>对于产生内存的问题，可以通过开启 <code>-XX:+UseCMSCompactAtFullCollection</code>，在每次 <code>Full GC</code> 完成后都会进行一次「内存压缩整理」，将零散在各处的对象整理到一块。</p><p>设置参数 <code>-XX:CMSFullGCsBeforeCompaction</code> 告诉 <code>CMS</code>，经过了 N 次 <code>Full GC</code> 之后再进行一次内存整理。</p></blockquote><blockquote><p>适用场景</p></blockquote><p><code>CMS</code>以获取最短回收停顿时间为目标，<strong>非常符合在注重用户体验的应用上使用。</strong></p><h2 id="通用收集器" tabindex="-1"><a class="header-anchor" href="#通用收集器" aria-hidden="true">#</a> 通用收集器</h2><h3 id="garbage-first-g1" tabindex="-1"><a class="header-anchor" href="#garbage-first-g1" aria-hidden="true">#</a> Garbage First(G1)</h3><blockquote><p>什么是G1?</p></blockquote><p><code>G1</code> 收集器以极高概率满足 <code>GC</code> 停顿时间要求的同时，还具备高吞吐量性能特征。</p><p><code>HotSpot</code> 开发团队赋予<code>G1</code>的使命是未来可以替换掉 <code>CMS</code> 收集器。</p><p><strong><code>G1</code>没有新生代和老年代的概念，而是将堆划分为一块块独立的 <code>Region</code>（重新定义堆空间）</strong>。也因此我们把<code>G1</code>分类成「通用收集器」。</p><ul><li><blockquote><p>什么是Region？</p></blockquote><img src="https://pixel-revolve.oss-cn-hangzhou.aliyuncs.com/img/image-20221012191936482.png" alt="image-20221012191936482" style="zoom:50%;"><p>通过引入 <code>Region</code> 的概念，原来一整块内存空间划分成多个的小空间（新生代和老年代不再物理隔离），使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。</p><p><code>Region</code>的大小是一致的，数值是在1M到32M字节之间的一个2的幂值数，<code>JVM</code>会尽量划分2048个左右、同等大小的<code>Region</code>。</p><p>通过记录每个 <code>Region</code> 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个「优先列表」，每次根据允许的收集时间，优先回收价值最大的 <code>Region</code>。</p></li><li><blockquote><p>为什么需要Region？</p></blockquote><p>这么做的目的是在进行收集时<strong>不必在全堆范围内进行</strong>，这是它最显著的特点。</p><p>区域划分的好处就是带来了「停顿时间可预测的收集模型」（用户可以指定收集操作在多长时间内完成）。可以说<code>G1</code>提供了接近实时的收集特性。</p><p><strong><code>G1</code>收集器之所以能建立「停顿时间可预测的收集模型」，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集</strong>。</p><p><code>G1</code> 会通过一个合理的计算模型，<strong>计算出每个<code>Region</code>的收集成本并量化</strong>。这样收集器在给定了“停顿”时间限制的情况下，总是能选择一组恰当的<code>Regions</code>作为收集目标，让其收集开销满足这个限制条件，以此达到实时收集的目的。</p><p>由于每次都是回收价值最大的<code>Region</code>，因此可以获得最大的回收效率。</p><p>由于侧重点在于回收最大垃圾量的<code>Region</code>，<strong>这个特点让<code>G1</code>获得了Garbage First（垃圾优先）的名字。</strong></p></li><li><blockquote><p>一个对象和它内部所引用的对象可能不在同一个 Region 中，那么当垃圾回收时，是否需要扫描整个堆内存才能完整地进行一次可达性分析？</p></blockquote><p>并不！每个 <code>Region</code> 都有一个 <code>Remembered Set</code>，用于记录本区域中所有对象引用的对象所在的区域，进行可达性分析时，只要在 <code>GC Roots </code>中再加上 <code>Remembered Set</code> 即可防止对整个堆内存进行遍历。</p><blockquote><p>关于<code>Remembered Set</code>的内容我在我的博客：<a href="https://juejin.cn/post/7153141395958530056" target="_blank" rel="noopener noreferrer">从零开始的JVM学习--GC</a>的「分代收集理论」章节中有有介绍</p></blockquote></li></ul><blockquote><p>G1的特点</p></blockquote><ul><li><p><strong>并行与并发</strong></p><p><code>G1</code>能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短<code>Stop The World</code>的时间。</p><p>部分其他收集器原来需要停顿Java线程执行的<code>GC</code>操作，<code>G1</code>收集器仍然可以通过<strong>并发</strong>的方式让Java程序继续运行。</p></li><li><p><strong>分代收集</strong></p><p>从分代上看，<code>G1</code>依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有<code>Eden</code>区和<code>Survivor</code>区。</p><p>但从堆的结构上看，它不要求整个<code>Eden</code>区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</p><p>将堆空间分为若干个区域(<code>Region</code>) , 这些区域中包含了逻辑上的年轻代和老年代。</p><p>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代;</p></li><li><p><strong>空间整合</strong></p><p>从整体上看， <code>G1</code> 是基于「标记-整理算法」实现的收集器。</p><p>从局部（两个 <code>Region</code> 之间）上看是基于「复制算法」实现的。</p><p>但无论如何，这两种算法都意味着<code>G1</code>运作期间<strong>不会产生内存空间碎片</strong>，收集后能提供规整的可用内存。</p><p>这种特性<strong>有利于程序长时间运行</strong>，分配大对象时不会因为无法找到连续内存空间而提前触发下一次<code>GC</code>。</p></li><li><p><strong>可预测的停顿</strong></p><p>这是<code>G1</code>相对于<code>CMS</code>的一个优势，降低停顿时间是<code>G1</code>和<code>CMS</code>共同的关注点。</p></li></ul><blockquote><p>G1收集器的工作流程</p></blockquote><p>如果不计算维护 <code>Remembered Set</code> 的操作，<code>G1</code> 收集器的工作过程分为以下几个步骤：</p><ul><li><p><strong>初始标记</strong></p><p><strong><code>Stop The World</code>，但是耗时很少。<strong>仅使用</strong>一条</strong>初始标记线程对所有与 <code>GC Roots</code>「 直接关联」的对象进行标记。并且修改<code>TAMS</code>（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的<code>Region</code>中创建新对象，</p></li><li><p><strong>并发标记</strong></p><p>不需要停顿。此过程进行「可达性分析」，找出存活对象。<strong>这阶段耗时较长</strong>，但可与用户程序并发执行。</p></li><li><p><strong>最终标记</strong></p><p><strong><code>Stop The World</code>，但是可以并行执行。<strong>使用</strong>多条</strong>标记线程并发执行。是为了修正「并发标记」期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中</p></li><li><p><strong>筛选回收</strong></p><p><strong>可以和用户线程并发执行</strong>。首先对各个<code>Region</code>的回收价值和成本进行排序，**根据用户所期望的<code>GC</code>停顿时间来制定回收计划。**因为只回收一部分<code>Region</code>，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</p></li></ul><blockquote><p>相关参数设置</p></blockquote><ul><li><p><code>-XX:+UseG1GC</code> 指定使用<code>G1</code>收集器。</p></li><li><p><code>-XX:G1HeapRegionSize</code> 设置每个<code>Region</code>的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</p></li><li><p><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大<code>GC</code>停顿时间指标(<code>JVM</code>会尽力实现，但不保证达到)。默认值是200ms</p></li><li><p><code>-XX:ParallelGCThread</code> 设置<code>STW</code>工作线程数的值。最多设置为8</p></li><li><p><code>-XX:ConcGCThreads</code> 设置并发标记的线程数。将n设置为并行垃圾回收线程数(<code>ParallelGCThreads</code>)的1/4左右。</p></li><li><p><code>-XX:InitiatingHeapOccupancyPercent</code> 设置触发并发<code>GC</code>周期的Java堆占用率阈值。超过此值，就触发<code>GC</code>。默认值是45。</p></li></ul><blockquote><p>适用场景</p></blockquote><p><code>G1</code>是一款面向服务端应用的垃圾收集器。主要针对配备多核CPU，及大容量内存的机器。</p><p>如果发现以下特征可以考虑使用<code>G1</code>收集器以追求更佳性能：</p><ul><li>实时数据占用了超过半数的堆空间；</li><li>对象分配率或“晋升”的速度变化明显；</li><li>期望消除耗时较长的<code>GC</code>或停顿（超过0.5——1秒）。</li></ul><h1 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h1><p>本篇文章介绍了最经典主流的几款垃圾收集器。根据工作的位置不同对它们进行了分类，并且根据工作特点介绍了它们各自的适用场景。</p><p>其他还有很多的垃圾收集器比如<code>Shenandoah</code>，<code>ZGC</code>，<code>AliGC</code>，<code>Zing</code>... 但是由于它们不是那么主流和篇幅原因没有放到本章介绍，以后有机会我也会专门写博客介绍。</p><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h1><p>本文参考：</p><ul><li><p>https://doocs.github.io/jvm/04-hotspot-gc.html</p></li><li><p>https://www.cnblogs.com/ronnieyuan/p/12349959.html</p></li><li><p>https://juejin.cn/post/6844903974676463629</p></li></ul><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></footer><!----><!--[--><!--]--><!----></main><ul class="catalog" style="top:0px;"><li class="level-2 toc-link-什么是垃圾收集器">什么是垃圾收集器</li><li class="level-2 toc-link-安全点-safepoint">安全点（SafePoint）</li><li class="level-2 toc-link-新生代收集器">新生代收集器</li><li class="level-3 toc-link-serial">Serial</li><li class="level-3 toc-link-parnew">ParNew</li><li class="level-3 toc-link-parallel-scavenge">Parallel Scavenge</li><li class="level-2 toc-link-老年代收集器">老年代收集器</li><li class="level-3 toc-link-serial-old">Serial Old</li><li class="level-3 toc-link-parallel-old">Parallel Old</li><li class="level-3 toc-link-cms">CMS</li><li class="level-2 toc-link-通用收集器">通用收集器</li><li class="level-3 toc-link-garbage-first-g1">Garbage First(G1)</li></ul></div><!--]--></div><div class="search-page" role="search"><span class="search-close"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" width="28" height="28" fill="currentColor"><path d="M224 416c-8.188 0-16.38-3.125-22.62-9.375l-192-192c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L224 338.8l169.4-169.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-192 192C240.4 412.9 232.2 416 224 416z"></path></svg></span><div class="gungnir-search-box"><input placeholder="$ grep ..." autocomplete="off" spellcheck="false" value><!----></div></div><div class="menu-btn-container"><div class="menu-btn-wrapper"><div class="menu-btn"><div style="" class="menu-btn-icon"><span></span><span></span><span></span></div><div style="display:none;" class="menu-text">0</div><svg class="menu-progress"><circle class="menu-border" cx="50%" cy="50%" r="48%" style="stroke-dasharray:0% 314.15926%;"></circle></svg></div><div class="menu-btn-child-wrapper"><div class="toggle-dark-button menu-btn-child" title="toggle dark mode"><svg class="ov-icon" style="font-size:1.2em;display:none;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"/></svg><svg class="ov-icon" style="font-size:1.2em;display:none;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 00283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"/></svg><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M224 96l16-32 32-16-32-16-16-32-16 32-32 16 32 16 16 32zM80 160l26.66-53.33L160 80l-53.34-26.67L80 0 53.34 53.33 0 80l53.34 26.67L80 160zm352 128l-26.66 53.33L352 368l53.34 26.67L432 448l26.66-53.33L512 368l-53.34-26.67L432 288zm70.62-193.77L417.77 9.38C411.53 3.12 403.34 0 395.15 0c-8.19 0-16.38 3.12-22.63 9.38L9.38 372.52c-12.5 12.5-12.5 32.76 0 45.25l84.85 84.85c6.25 6.25 14.44 9.37 22.62 9.37 8.19 0 16.38-3.12 22.63-9.37l363.14-363.15c12.5-12.48 12.5-32.75 0-45.24zM359.45 203.46l-50.91-50.91 86.6-86.6 50.91 50.91-86.6 86.6z"/></svg></div><div class="menu-btn-child"><svg class="ov-icon" style="font-size:1.7999999999999998em;" aria-hidden="true" width="28.799999999999997" height="28.799999999999997" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"/></svg></div><div class="menu-btn-child"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-75.52 -43.52 599.04 599.04" fill="currentColor"><path d="M240.971 130.524l194.343 194.343c9.373 9.373 9.373 24.569 0 33.941l-22.667 22.667c-9.357 9.357-24.522 9.375-33.901.04L224 227.495 69.255 381.516c-9.379 9.335-24.544 9.317-33.901-.04l-22.667-22.667c-9.373-9.373-9.373-24.569 0-33.941L207.03 130.525c9.372-9.373 24.568-9.373 33.941-.001z"/></svg></div><div class="menu-btn-child menu-toc-btn"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-43.52 -43.52 599.04 599.04" fill="currentColor"><path d="M48 48a48 48 0 1048 48 48 48 0 00-48-48zm0 160a48 48 0 1048 48 48 48 0 00-48-48zm0 160a48 48 0 1048 48 48 48 0 00-48-48zm448 16H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16v-32a16 16 0 00-16-16zm0-320H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16V80a16 16 0 00-16-16zm0 160H176a16 16 0 00-16 16v32a16 16 0 0016 16h320a16 16 0 0016-16v-32a16 16 0 00-16-16z"/></svg></div><div class="toggle-sidebar-button menu-btn-child menu-btn-sidebar" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><svg class="ov-icon" style="font-size:1.2em;" aria-hidden="true" width="19.2" height="19.2" viewBox="-1.6 -1.6 19.2 19.2" fill="currentColor"><path d="M14 2a1 1 0 011 1v10a1 1 0 01-1 1H2a1 1 0 01-1-1V3a1 1 0 011-1h12zM2 1a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V3a2 2 0 00-2-2H2z"/><path d="M3 4a1 1 0 011-1h2a1 1 0 011 1v8a1 1 0 01-1 1H4a1 1 0 01-1-1V4z"/></svg></div></div></div></div><footer class="footer"><span>
                &copy; pixel-revolve 2021-2022
                <br>
                Powered by <a href="https://vuepress.vuejs.org" target="_blank">VuePress</a> &
                <a href="https://github.com/Renovamen/vuepress-theme-gungnir" target="_blank">Gungnir</a>
                </span></footer></div><!--]--></div>
    <script type="module" src="/assets/app.9fd9aa02.js" defer></script>
  </body>
</html>
